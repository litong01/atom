#!/bin/bash

ColorOff='\033[0m'        # Text Reset
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
SCRIPTDIR=$(dirname $0)
APPNAME=$(basename "$0")
TYPE="acc"
CURDIR=$(pwd)
WORKDIR=${WORKDIR:-/tmp/astra}
COMPONENT="all"
NAMESPACE="${NAMESPACE:-pcloud}"
IMAGE_REPOSITORY=${IMAGE_REPOSITORY:-docker.repo.eng.netapp.com/globalcicd/astra}
CLUSTER_ENDPOINT=${CLUSTER_ENDPOINT:-integration.astra.netapp.io}
IMAGENAME=""

function printHelp() {
  echo ""
  echo "Usage:"
  echo "    ${APPNAME} <cmd> [options]"
  echo ""
  echo -e "Available commands:"
  echo "     up       - Start up astra network include cluster"
  echo "     down     - Remove all astra but k8s cluster"
  echo "     image    - Update image to the local repo"
  echo "     prepare  - Get cluster and image ready"
  echo "     deploy   - Deploy astra components"
  echo "     clean    - Remove all astra including k8s cluster"
  echo "     cleanall - Remove all astra including k8s cluster, proxy, local registry"
  echo "     trident  - Set up trident"
  echo "     pull     - pull tagged commit image from repo"
  echo "     update   - update this tool"
  echo "     refresh  - restart a deployment and its image"
  echo "     make     - run polaris make command"
  echo "     k8stool  - run k8stool command with parameters"
  echo ""
  echo -e "Product type, valid values are ACC or ACS"
  echo "     -t|--type  - Astra product type. valid options are acc and acs, default is acs"
  echo ""
  echo -e "Parameters for ${Green}image${ColorOff} command:"
  echo "     -i|--imagename  - an astra image name. default is all images"
  echo ""
  echo -e "Parameters for ${Green}pull${ColorOff} command:"
  echo "     -i|--imagename   - an astra image name. default is all images"
  echo ""
  echo -e "Parameters for ${Green}deploy${ColorOff} command:"
  echo "     -a|--astra-name) - a name of astra component to be deployed. Valid option"
  echo "                        are all, main, traefik, post, dash default is all"
  echo "        --context)    - a kubernetes context to use, if not specified, the"
  echo "                        current kubernetes context will be used"
  echo ""
  echo -e "Parameters for ${Green}refresh${ColorOff} command:"
  echo "     -d|--deployment-name  - a deployment name such as identity"
  echo "     -n|--namespace        - the namespace where the deployment is, default pcloud"
  echo "        --context)         - a kubernetes context to use, if not specified, the"
  echo "                             current kubernetes context will be used"
  echo ""
}

function validateCMD() {
  cmd=$1
  allCommands=("up" "down" "image" "deploy" "clean" "cleanall" "prepare" "pull" "refresh" "make" "update" "k8stool" "trident")
  ccmd=""
  for item in "${allCommands[@]}"; do
    if [[ "${cmd}" == "${item}" ]]; then
      ccmd="${cmd}"
      isValidCMD="true"
      break
    fi
  done
  if [[ -z "${ccmd}" ]]; then
    if [[ "${cmd}" != "-h" ]] && [[ "${cmd}" != "--help" ]] && [[ "${cmd}" != "" ]]; then
      echo ""
      echo -e "ERROR: ${Red}${cmd}${ColorOff} is not a supported command!"
      printHelp "${isValidCMD}"
      exit 1
    else
      printHelp "${isValidCMD}"
      exit 0
    fi
  fi
}

CMD=$1
shift
# This saves the rest of the command in case it is to pass along for make command
REST="$@"
# Validate the command
validateCMD "${CMD}"

# We will only handle command parameters if command was not make and not k8stool
if [[ "${CMD}" != "make" ]] && [[ "${CMD}" != "k8stool" ]]; then
  # Handling parameters
  while [[ $# -gt 0 ]]; do
    optkey="$1"
    case $optkey in
      -h|--help)
        printHelp "true"; exit 0;;
      --context)
        CONTEXT="$2";shift 2;;
      --targetports)
        TARGETPORTS="$2";shift 2;;
      -n|--namespace)
        NAMESPACE="$2";shift 2;;
      -w|--workdir)
        WORKDIR="$2";shift 2;;
      -a|--astra-name)
        COMPONENT="$2";shift 2;;
      -d|--deployment-name)
        DEPLOYMENT="$2";shift 2;;
      -i|--imagename)
        IMAGENAME="$2";shift 2;;
      -t|--type)
        TYPE="$2";shift 2;;
      *) # unknown option
        echo "parameter $1 is not supported"; exit 1;;
    esac
  done
fi

function validateContext() {
  # Context was not set, trying to use current context
  if [[ -z "${CONTEXT}" ]]; then
    # Get current context
    ctx=$(kubectl config current-context 2>/dev/null || true)
  else # Context was set, verify it exists in the kubernetes context
    ctx=$(kubectl config get-contexts "${CONTEXT}" -o=name 2>/dev/null || true)
  fi

  if [[ -z "${ctx}" ]]; then
    echo -e "${Red}No kubernetes context available, cannot continue${ColorOff}"
    exit 1
  fi

  CONTEXT="${ctx}"
}

function doADTUpdate() {
  adtimage=$(docker inspect astra --format "{{.Config.Image}}" 2>/dev/null || true)
  if [[ ! -z "${adtimage}" ]]; then
    # Using the github token and id to login
    echo $GITHUB_TOKEN | docker login -u ${GITHUB_ID} --password-stdin ghcr.io >/dev/null 2>&1
    # Pull the image
    docker pull "${adtimage}"
    # Try to clean up dangling images, use a variable to avoid none 0 return
    notuseval=$(docker rmi -f $(docker images -f "dangling=true") >/dev/null 2>&1 || true)
  fi
}

function loginToDockerHub() {
  if [[ ! -z "${GITHUB_ID}" ]] && [[ ! -z "${GITHUB_TOKEN}" ]]; then
    echo -e "${Green}Logging into docker hub...${ColorOff}"
    echo $DH_TOKEN | docker login -u $DH_ID --password-stdin docker.io >/dev/null 2>&1
  fi
}

function checkEnvironmentVariables() {
  envs=(DEPLOY_TYPE VAULT_ADDR GITHUB_USERNAME \
        GITHUB_TOKEN GITHUB_ID CREDS_AUTH_CLIENT_ID \
        CREDS_AUTH_DOMAIN CREDS_ISSUER_URL CLUSTER_ENDPOINT IMAGE_HOST)
  for value in ${envs[@]}; do
    if [[ -z ${!value} ]]; then
      echo -e "${Red}${value}${ColorOff} was not set, quiting..."
      exit 1
    elif [[ "${value}" == "GITHUB_TOKEN" ]] || [[ "${value}" == "CREDS_IMAGE_PASSWORD" ]]; then
      echo -e "${Green}${value}${ColorOff}=************"  
    else
      echo -e "${Green}${value}${ColorOff}=${!value}"
    fi
  done
}

function checkInPolaris() {
    # check that the Makefile and pcloud directory exists
    if [[ ! -f "${CURDIR}/Makefile" ]] || [[ ! -d "${CURDIR}/pcloud" ]]; then
      echo -e "${Red}You are not in Polaris root directory, quiting...${ColorOff}"
      exit 1
    fi
}

function deployDashboard() {
  # Get needed prometheus and grafana docker image
  loginToDockerHub
  dashImages=("prom/prometheus:v2.42.0" "grafana/grafana:9.4.3")
  for item in "${dashImages[@]}"; do
    echo -e "${Green}Pulling image ${item}...${ColorOff}"
    docker pull ${item}
    ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${item}" --context ${CONTEXT}
  done
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/prometheus.yaml
  kubectl --context ${CONTEXT} apply -n $NAMESPACE -f ${HOME}/addon/acs-north-star-dashboards.yaml
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/grafana.yaml
}

kill_port_forward() {
  service=$1
  processes=$(ps -a | grep 'kubectl' | grep 'port-forward' | grep "${service}")
  process_ids=$(echo "${processes}" | cut -d ' ' -f1)
  if [ -n "${process_ids}" ]; then
    echo "${process_ids}" | xargs kill -2 2>&1 > /dev/null
    sleep 3
  fi
  echo -e "${Green}Port-forward for ${service} has stopped. ${ColorOff}"
}

forward_port() {
  service=$1
  ${SCRIPTDIR}/pcloud-port-forward -s "${service}" 2>&1 > /dev/null &
  sleep 3 # takes a few seconds to get started (especially with remote clusters)

  echo -e "${Green}Port-forward for ${service} has started. ${ColorOff}"
}

function wait_for_pod() {
  # Since the billing, trident-svc and bucketservice are the ones become available latest
  # We will just watch them.
  echo -e "${Green}Waiting for pods to be ready...${ColorOff}"
  while : ; do
    if kubectl wait pod --context ${CONTEXT} -n ${NAMESPACE} --for=condition=ready \
      -l 'app.kubernetes.io/name in (billing, trident-svc, bucketservice)' --timeout=120s 2>&1; then
       break
    fi
    sleep 5
  done
  echo -e "${Green}ACS pods are ready now${ColorOff}"
}

ACCOUNTINDEX=1
function saveAccountIndex() {
  content="ACCOUNTINDEX=${ACCOUNTINDEX}"
  echo ${content} > /home/work/astra/accountIndex.sh
}

function loadAccountIndex() {
  if [ -f /home/work/astra/accountIndex.sh ]; then
    source /home/work/astra/accountIndex.sh
  fi
  # If we have used up all the numbers, we should reset
  if [[ ${ACCOUNTINDEX} -ge 100 ]]; then
    ACCOUNTINDEX=1
  fi
}

function initACS() {
  # Get sre token
  wait_for_pod
  forward_port credentials

  # Run setting service accounts
  python3 ${SCRIPTDIR}/serviceaccount.py

  # Now stop the port forwarding
  kill_port_forward credentials
}

function deployAccounts() {

  forward_port krakend
  loadAccountIndex

  # Create 3 accounts each time
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))

  saveAccountIndex

  # Now stop the port forwarding
  kill_port_forward krakend
}

function deployACC() {
  # Get latest astra version
  # It seems that the versions of ACC component rely on enterprise-helm-repo. So we do
  # things based on that repo. It is important for local development, one should built
  # this container image first using this command
  #    KUBE_CONTEXT=astra-kind SKIP_KUBE_CONTEXT_CHECK=true make enterprise-helm-repo ENTERPRISE=true
  # then tag it with localhost:5001/enterprise-helm-repo:<whatever>
  # what is very important is that the repo versions and code are in sync.
  source /home/bin/astraimage
  itag=$(docker images enterprise-helm-repo --format "{{.Tag}}")
  if [[ -z "${itag}" ]]; then
    aversion=$(${CURDIR}/cicd/scripts/get_latest_version_tag.sh --version-only astra)
    # itag=$(${CURDIR}/cicd/scripts/increment_build_version.sh --release-versioning false ${aversion})
    PullTagPushOneACImage "enterprise-helm-repo:${aversion}"
  else
    docker tag "enterprise-helm-repo:${itag}" "localhost:5001/enterprise-helm-repo:${itag}"
    docker push "localhost:5001/enterprise-helm-repo:${itag}"
  fi

  # Certificate falls over always. Use the fixed up certificates for now.
  fixcertificateimage
  accoptag=$(getServiceTag 'acc-operator')
  echo -e "${Green}Deploying Astra version ${itag}...${ColorOff}"

  set -
  cd /home/acc

  # Setup netapp-acc-operator
  accopns="netapp-acc-operator"
  # Create the namespace
  kubectl create --context="${CONTEXT}" namespace ${accopns} 2>/dev/null || true

  # Create the certificate
  ${SCRIPTDIR}/k8stool cert --namespace ${accopns} --context ${CONTEXT} --workdir "${WORKDIR}"

  # getting the nginx image:
  docker pull nginx:1.23.4
  docker tag nginx:1.23.4 localhost:5001/nginx:1.23.4
  docker push localhost:5001/nginx:1.23.4

  registryip=$(docker inspect kind-registry --format "{{.NetworkSettings.Networks.kind.IPAddress}}" 2>/dev/null || true)
  if [[ -z "${registryip}" ]]; then
     echo -e "${Red}Local registry is not working, cannot continue${ColorOff}"
     exit 1
  fi
  sed -i "s/KIND_REGISTRY_IP/${registryip}/" nginx.yaml

  # This deployment is to ensure that acc operator happy with the image registry
  # Deploy the service to the namespace
  kubectl apply -n ${accopns} -f nginx.yaml

  # Repair the image tag for acc operator
  imgtag="${IMAGE_HOST}/kube-rbac-proxy:v4.8.0" yq 'select(document_index == 11).spec.template.spec.containers[0].image = env(imgtag)' \
    -i astra_control_center_operator_deploy.yaml
  imgtag="${IMAGE_HOST}/acc-operator:${accoptag}" yq 'select(document_index == 11).spec.template.spec.containers[1].image = env(imgtag)' \
    -i astra_control_center_operator_deploy.yaml

  set +
  # Now run the whole deployment process
  echo -e "${Green}Deploying ACC...${ColorOff}"
  # ${CURDIR}/acc-operator/astractl/astractl deploy --registry "kind-registry:5001" --timeout 300 --astra-version "${itag}" \
  #   --ingress-type AccTraefik --astra-resources-scalar "Default" --additional-values \
  #   '{"activity":{"replicas":1},"polaris-mongodb":{"mongodb":{"persistence":{"size":"5Gi"},"replicaCount":1,"image":{"registry":"ghcr.io","tag":"5.0.14","repository":"zcube/bitnami-compat/mongodb"}}},"polaris-consul":{"consul":{"server":{"replicas":1,"bootstrapExpect":1,"storage":"2Gi","resources":{"limits":{"memory":"50Mi"}}}}},"keycloak-operator":{"replicaCount":1},"polaris-keycloak":{"replicaCount":1,"mariadb-galera":{"replicaCount":1}},"features":{"replicas":1,"resources":{"requests":{"cpu":"10m","memory":"40Mi"}}},"loki":{"persistence":{"size":"5Gi"},"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"asup":{"persistence":{"size":"5Gi"},"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"nautilus":{"replicaCount":1,"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"polaris-influxdb2":{"persistence":{"size":"5Gi"},"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"traefik":{"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"task-service":{"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"nats":{"replicaCount":1},"polaris-vault":{"vault":{"server":{"ha":{"replicas":1},"auditStorage":{"size":"2Gi"}}}},"certificates":{"replicas":1},"credentials":{"replicas":1},"krakend":{"replicas":1},"openapi":{"replicas":1},"vault-controller":{"replicas":1},"cert-manager":{"cert-manager":{"replicaCount":1,"webhook":{"replicaCount":1},"cainjector":{"replicaCount":1}}}}'
  
  # Now deploy acc operator first
  kubectl apply --context ${CONTEXT} -n ${accopns} -f astra_control_center_operator_deploy.yaml

  # Now fix up the astra version
  astraVersion="${itag}" yq '.spec.astraVersion = env(astraVersion)' -i acc.yaml

  # Deploy astra control center
  kubectl create --context="${CONTEXT}" namespace ${NAMESPACE} 2>/dev/null || true
  kubectl apply --context="${CONTEXT}" -n ${NAMESPACE} -f acc.yaml

  # Wait for the polaris-ui pod to become ready, this can be a long wait.
  echo -e "Waiting for polaris to become ready..."
  startTime=$(date +%s)
  while : ; do
    updateKeycloakOperatorSetting
    res=$(kubectl wait --context "${CONTEXT}" -n ${NAMESPACE} pod \
      -l "app.kubernetes.io/name=traefik" --for=condition=Ready --timeout=30s 2>/dev/null ||true)
    if [[ "${res}" == *"condition met"* ]]; then
      break
    fi
    currentTime=$(date +%s)
    elapsed=$(( currentTime - startTime ))
    echo -ne "\033[0K\r"
    echo -ne "   Time elapsed: ${Green}${elapsed}${ColorOff} seconds\033[0K"
    sleep 30
  done

  set -

  # Setup the proxy
  echo ""
  echo -e "${Green}Creating path to access ACC...${ColorOff}"
  ${SCRIPTDIR}/k8stool proxy --targetports "traefik 80 443" --workdir "${WORKDIR}" --context ${CONTEXT}

  # Get the user name and password for login
  loginpw=$(kubectl get astracontrolcenters.astra.netapp.io -n ${NAMESPACE} -o jsonpath='ACC-{..uid}')
  echo -e "${Green}Astra Control Center has been successfully setup${ColorOff}"
  echo -e "Use the following to login"
  echo -e "   Email: ${Green}admin@integration.astra.netapp.io${ColorOff}"
  echo -e "   Password: ${Green}${loginpw}${ColorOff}"
}
  
function fixcertificateimage() {
  # this method pulls the certificate image I fixed and use it for development
  echo $GITHUB_TOKEN | docker login -u ${GITHUB_ID} --password-stdin ghcr.io >/dev/null 2>&1
  docker pull ghcr.io/netapp-polaris/polaris/astra/certificates:astradt
  tag=$(getServiceTag certificates)
  docker tag ghcr.io/netapp-polaris/polaris/astra/certificates:astradt "certificates:${tag}"
  docker tag ghcr.io/netapp-polaris/polaris/astra/certificates:astradt "localhost:5001/certificates:${tag}"
}

function updateKeycloakOperatorSetting() {
  # This function will update the keycloak operator two hidden env to be 1
  # If the operator is ready, it will update, otherwise, it will do nothing.
  res=$(kubectl wait --context "${CONTEXT}" -n ${NAMESPACE} pod \
    -l "app.kubernetes.io/name=keycloak-operator" --for=condition=Ready --timeout=30s 2>/dev/null ||true)
  if [[ "${res}" == *"condition met"* ]]; then
    # It is ready, we need to apply the patch to it now.
    kubectl set env --context "${CONTEXT}" -n "${NAMESPACE}" deployment/keycloak-operator \
      KCOP_KEYCLOAK_REPLICAS=1 KCOP_KEYCLOAK_DBREPLICAS=1 >/dev/null 2>&1
  fi
}

function deployAC() {
  CNAME=$1
  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "traefik" ]]; then
    rm -rf /home/polaris/build
    echo -e "${Green}Ready to deploy traefik${ColorOff}"
    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true \
    make traefikinstall DEPLOY_TARGET=local \
    CLUSTER_ENDPOINT=integration.astra.netapp.io \
    TRAEFIK_ENDPOINT=integration.astra.netapp.io NAMESPACE=${NAMESPACE}

    # Only setup proxy when doing things locally.
    if [[ ${CLUSTER_ENDPOINT} == "integration.astra.netapp.io" ]]; then
      echo -e "${Green}Setting up proxy...${ColorOff}"
      ${SCRIPTDIR}/k8stool proxy --targetports "traefik 80 443" --workdir "${WORKDIR}" --context ${CONTEXT}
    fi
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "main" ]]; then
    rm -rf /home/polaris/build
    echo -e "${Green}Ready to deploy Astra${ColorOff}"

    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true IMAGE_HOST=${IMAGE_HOST} \
    make helminstall DEPLOY_TARGET=cicd NAUTILUS_REPLICAS=1 \
    CLUSTER_ENDPOINT=integration.astra.netapp.io \
    TRAEFIK_ENDPOINT=integration.astra.netapp.io \
    HELMOVERRIDE='--set mongodb.image.registry=${IMAGE_HOST} --set mongodb.image.repository=mongodb --set mongodb.image.tag=5.0.14 --set mongodb.replicaCount=1'

    # For now remove the services/deployments that not needed
    kubectl delete --context ${CONTEXT} -n ${NAMESPACE} deployment natssync-server httpproxy-server hybridauth 2>/dev/null||true
    kubectl delete --context ${CONTEXT} -n ${NAMESPACE} service natssync-server httpproxy-server hybridauth 2>/dev/null||true
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "dash" ]]; then
    echo -e "${Green}Deploy dashboard...${ColorOff}"
    deployDashboard
  fi

  # This has to be done always, no need to run again if successful
  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "service" ]]; then
    echo -e "${Green}Setting up service accounts...${ColorOff}"
    initACS
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "user" ]]; then
    echo -e "${Green}Setting up user accounts...${ColorOff}"
    deployAccounts
  fi
}

function getServiceTag() {
  release_name=$1
  version=$(${CURDIR}/cicd/scripts/calculate_service_version.sh ${release_name} --release-versioning false)
  echo "${version}"
}

function refreshDeployment() {
  if [[ "${DEPLOYMENT}" == "" ]]; then
    echo -e "${Red}Use -d parameter to specify a deployment to be refreshed${ColorOff}"
    exit 1
  else
    OLDIFS=$IFS
    dep=$(kubectl --context ${CONTEXT} get -n ${NAMESPACE} deployment "${DEPLOYMENT}" -o \
      jsonpath='{.spec.template.spec.containers[*].image}' 2>/dev/null||true)
    if [[ "${dep}" == "" ]]; then
      echo -e "${Red}Could not find the deployment ${DEPLOYMENT}${ColorOff}"
      IFS=$OLDIFS
      exit 1
    else
      # Now need to get the tag and the actual image name
      IFS=$'/' parts=($(echo "${dep}"|rev))
      imagename=$(echo "${parts[0]}"|rev)
      IFS=$OLDIFS
      if [[ "${imagename}" != "" ]]; then
        echo "Ready to update ${imagename}"
        if [[ "${dep}" =~ "${IMAGE_HOST}" ]]; then
          # astra image, push the newer image
          ${SCRIPTDIR}/k8stool image --source-tag "${imagename}"
          # Remove the cached image
          docker exec astra-control-plane crictl rmi "${dep}" 2>/dev/null || true
        else
          # other images
          ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${imagename}"
        fi
        kubectl --context ${CONTEXT} rollout restart -n ${NAMESPACE} deployment ${DEPLOYMENT}
      fi
    fi
  fi
}


function setupTrident() {
  set +e
  tridentns="trident"
  kubectl get namespace ${tridentns} --context "${CONTEXT}" >/dev/null 2>&1
  # namespace does not exist, create it
  if [[ $? == 1 ]]; then
    echo "Creating namespace ${tridentns}"
    set -e
    kubectl create ns ${tridentns} --context "${CONTEXT}"
  else
    echo "Namespace ${tridentns} already exists"
  fi
  set -e

  # Getting trident images
  tridentImages=("netapp/trident:23.01.1" "netapp/trident-autosupport:23.01" "netapp/trident-operator:23.01.1" \
    "registry.k8s.io/sig-storage/csi-provisioner:v3.4.0" "registry.k8s.io/sig-storage/csi-attacher:v4.1.0" \
    "registry.k8s.io/sig-storage/csi-resizer:v1.7.0" "registry.k8s.io/sig-storage/csi-snapshotter:v3.0.3" \
    "registry.k8s.io/sig-storage/csi-node-driver-registrar:v2.7.0")

  for item in ${tridentImages[@]}; do
    echo -e "${Green}Pulling image ${item}...${ColorOff}"
    docker pull --platform=linux/amd64 ${item}
    ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${item}" --context ${CONTEXT}
  done

  echo -e "${Green}Deploying trident onto kubernetes cluster...${ColorOff}"
  kubectl --context "${CONTEXT}" apply -f /home/trident/tridentorchestrator.yaml -n ${tridentns}
  echo "Trident CRDs are deployed"
  ARCH=$(uname -m) && if [[ "${ARCH}" == "aarch64" ]]; then ARCH=arm64; fi
  if [[ "${ARCH}" == "x86_64" ]]; then ARCH="amd64"; fi

  # Now make sure that the node using right architecture node label
  ARCH=$ARCH yq e '.spec.controllerPluginNodeSelector."kubernetes.io/arch" = env(ARCH)' -i /home/trident/tridentorchestrator_cr.yaml
  ARCH=$ARCH yq e '.spec.nodePluginNodeSelector."kubernetes.io/arch" = env(ARCH)' -i /home/trident/tridentorchestrator_cr.yaml

  # Deploy the orchestrator
  kubectl --context ${CONTEXT} apply -f /home/trident/tridentorchestrator_cr.yaml -n ${tridentns}
}

#=================Start main process=========================

set -e
# cluster processes
if [[ "${CMD}" == "up" ]]; then
  echo ""
  checkInPolaris
  checkEnvironmentVariables

  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  if [[ "${TYPE}" == "acc" ]]; then
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}" -w 2
  else
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  fi
  echo -e "${Green}Upload Astra images to image repostiory"
  validateContext

  echo ""
  echo -e "${Green}Process AC images...${ColorOff}"
  source "/home/bin/astraimage"
  SetupACComponentImage

  if [[ "${TYPE}" == "acc" ]]; then
    setupTrident
    deployACC
  else
    echo -e "${Green}Create traefik certificate${ColorOff}"
    ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
    deployAC "${COMPONENT}"
  fi

elif [[ "${CMD}" == "prepare" ]]; then
  echo ""
  checkInPolaris
  checkEnvironmentVariables

  echo ""
  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  if [[ "${TYPE}" == "acc" ]]; then
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}" -w 2
  else
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  fi
  echo -e "${Green}Upload Astra images to image repostiory"
  validateContext
  echo ""
  # Process external images needed
  echo ""
  echo -e "${Green}Process AC images...${ColorOff}"
  source "/home/bin/astraimage"
  SetupACComponentImage

  if [[ "${TYPE}" == "acc" ]]; then
    setupTrident
  else
    # echo -e "${Green}Create traefik certificate${ColorOff}"
    ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  fi

  echo -e "${Green}Ready to deploy Astra, please run deploy command${ColorOff}"

elif [[ "${CMD}" == "down" ]]; then
  echo ""
  echo -e "${Green}Removing Astra main components...${ColorOff}"
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  if [[ "${TYPE}" == "acs" ]]; then
    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true \
      make helmuninstall DEPLOY_TARGET=cicd
  else
    kubectl --context ${CONTEXT} delete -n pcloud astracontrolcenter astra
    kubectl --context ${CONTEXT} delete namespace netapp-acc-operator pcloud
  fi

elif [[ "${CMD}" == "clean" ]]; then
  echo -e "${Green}Removing Astra and cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d

elif [[ "${CMD}" == "cleanall" ]]; then
  echo -e "${Green}Removing everything...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d
  # Remove the proxy and the local registry as well
  docker rm -f kubeproxy &> /dev/null || true
  docker rm -f kind-registry &> /dev/null || true
  # Need to clean up docker volumes
  docker volume prune -f &> /dev/null || true
  rm -rf /home/work/astra/*.sh

elif [[ "${CMD}" == "image" ]]; then
  validateContext
  checkInPolaris
  checkEnvironmentVariables
  echo -e "${Green}Process AC images...${ColorOff}"
  source "/home/bin/astraimage"
  SetupACComponentImage

elif [[ "${CMD}" == "pull" ]]; then
  source "/home/bin/astraimage"
  SetupACComponentImage

elif [[ "${CMD}" == "deploy" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  # Always check and recreate namespace and the cert in case it was removed
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  if [[ "${TYPE}" == "acs" ]]; then
    deployAC "${COMPONENT}"
  else
    deployACC
  fi

elif [[ "${CMD}" == "refresh" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  refreshDeployment

elif [[ "${CMD}" == "trident" ]]; then
  validateContext
  loginToDockerHub
  setupTrident

elif [[ "${CMD}" == "update" ]]; then
  checkEnvironmentVariables
  doADTUpdate

elif [[ "${CMD}" == "make" ]]; then
  loginToDockerHub
  make ${REST}

elif [[ "${CMD}" == "k8stool" ]]; then
  echo ""
  echo -e "${Green}Running k8stool commands...${ColorOff}"
  ${SCRIPTDIR}/k8stool ${REST}

fi
#=================End main process=========================
