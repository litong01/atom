#!/bin/bash

ColorOff='\033[0m'        # Text Reset
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
SCRIPTDIR=$(dirname $0)
APPNAME=$(basename "$0")
TYPE="acc"
CURDIR=$(pwd)
WORKDIR=${WORKDIR:-/tmp/astra}
COMPONENT="all"
NAMESPACE="${NAMESPACE:-pcloud}"
IMAGE_REPOSITORY=${IMAGE_REPOSITORY:-docker.repo.eng.netapp.com/globalcicd/astra}
CLUSTER_ENDPOINT=${CLUSTER_ENDPOINT:-integration.astra.netapp.io}
IMAGENAME=""


declare -A ACSIMAGES
ACSIMAGES=(['activity']='' ['billing']='' ['bucketservice']='' ['asup']='' ['packages']='' ['license']='' \
  ['cloud-extension']='' ['composite-compute']='' ['composite-volume']='' ['credentials']='' ['cloud-insights-service']='' \
  ['entitlement']='' ['features']='' ['features_upgrade']='features' ['public-metrics']='' ['keycloak-operator']='' \
  ['graphql-server']='' ['hybridauth']='' ['identity']='' ['krakend']='' ['nautilus']='' ['openapi']='' ['polaris-ui']='' \
  ['support']='' ['support_hourly']='support' ['support_weekly']='support' ['task-service']='' ['authentication']='' \
  ['task-service_task_purge']='task-service' ['tenancy']='' ['tenancy_account_purge']='tenancy' ['metrics-facade']='' \
  ['trident-svc']='' ['acc-operator']='' ['vault-controller']='' ['certificates_upgrade']='certificates' \
  ['api-token-authentication']='' ['storage-backend-metrics']='' ['storage-provider']='' ['telemetry-service']='' \
  ['polaris-keycloak']='' ['login-ui']='' )

function printHelp() {
  echo ""
  echo "Usage:"
  echo "    ${APPNAME} <cmd> [options]"
  echo ""
  echo -e "Available commands:"
  echo "     up       - Start up astra network include cluster"
  echo "     down     - Remove all astra but k8s cluster"
  echo "     image    - Update image to the local repo"
  echo "     prepare  - Get cluster and image ready"
  echo "     deploy   - Deploy astra components"
  echo "     clean    - Remove all astra including k8s cluster"
  echo "     cleanall - Remove all astra including k8s cluster, proxy, local registry"
  echo "     trident  - Set up trident"
  echo "     pull     - pull tagged commit image from repo"
  echo "     update   - update this tool"
  echo "     refresh  - restart a deployment and its image"
  echo "     make     - run polaris make command"
  echo "     k8stool  - run k8stool command with parameters"
  echo ""
  echo -e "Product type, valid values are ACC or ACS"
  echo "     -t|--type  - Astra product type. valid options are acc and acs, default is acs"
  echo ""
  echo -e "Parameters for ${Green}image${ColorOff} command:"
  echo "     -i|--imagename  - an astra image name. default is all images"
  echo ""
  echo -e "Parameters for ${Green}pull${ColorOff} command:"
  echo "     -i|--imagename   - an astra image name. default is all images"
  echo ""
  echo -e "Parameters for ${Green}deploy${ColorOff} command:"
  echo "     -a|--astra-name) - a name of astra component to be deployed. Valid option"
  echo "                        are all, main, traefik, post, dash default is all"
  echo "        --context)    - a kubernetes context to use, if not specified, the"
  echo "                        current kubernetes context will be used"
  echo ""
  echo -e "Parameters for ${Green}refresh${ColorOff} command:"
  echo "     -d|--deployment-name  - a deployment name such as identity"
  echo "     -n|--namespace        - the namespace where the deployment is, default pcloud"
  echo "        --context)         - a kubernetes context to use, if not specified, the"
  echo "                             current kubernetes context will be used"
  echo ""
}

function validateCMD() {
  cmd=$1
  allCommands=("up" "down" "image" "deploy" "clean" "cleanall" "prepare" "pull" "refresh" "make" "update" "k8stool" "trident")
  ccmd=""
  for item in "${allCommands[@]}"; do
    if [[ "${cmd}" == "${item}" ]]; then
      ccmd="${cmd}"
      isValidCMD="true"
      break
    fi
  done
  if [[ -z "${ccmd}" ]]; then
    if [[ "${cmd}" != "-h" ]] && [[ "${cmd}" != "--help" ]] && [[ "${cmd}" != "" ]]; then
      echo ""
      echo -e "ERROR: ${Red}${cmd}${ColorOff} is not a supported command!"
      printHelp "${isValidCMD}"
      exit 1
    else
      printHelp "${isValidCMD}"
      exit 0
    fi
  fi
}

CMD=$1
shift
# This saves the rest of the command in case it is to pass along for make command
REST="$@"
# Validate the command
validateCMD "${CMD}"

# We will only handle command parameters if command was not make and not k8stool
if [[ "${CMD}" != "make" ]] && [[ "${CMD}" != "k8stool" ]]; then
  # Handling parameters
  while [[ $# -gt 0 ]]; do
    optkey="$1"
    case $optkey in
      -h|--help)
        printHelp "true"; exit 0;;
      --context)
        CONTEXT="$2";shift 2;;
      --targetports)
        TARGETPORTS="$2";shift 2;;
      -n|--namespace)
        NAMESPACE="$2";shift 2;;
      -w|--workdir)
        WORKDIR="$2";shift 2;;
      -a|--astra-name)
        COMPONENT="$2";shift 2;;
      -d|--deployment-name)
        DEPLOYMENT="$2";shift 2;;
      -i|--imagename)
        IMAGENAME="$2";shift 2;;
      -t|--type)
        TYPE="$2";shift 2;;
      *) # unknown option
        echo "parameter $1 is not supported"; exit 1;;
    esac
  done
fi

function validateContext() {
  # Context was not set, trying to use current context
  if [[ -z "${CONTEXT}" ]]; then
    # Get current context
    ctx=$(kubectl config current-context 2>/dev/null || true)
  else # Context was set, verify it exists in the kubernetes context
    ctx=$(kubectl config get-contexts "${CONTEXT}" -o=name 2>/dev/null || true)
  fi

  if [[ -z "${ctx}" ]]; then
    echo -e "${Red}No kubernetes context available, cannot continue${ColorOff}"
    exit 1
  fi

  CONTEXT="${ctx}"
}

function doADTUpdate() {
  adtimage=$(docker inspect astra --format "{{.Config.Image}}" 2>/dev/null || true)
  if [[ ! -z "${adtimage}" ]]; then
    # Using the github token and id to login
    echo $GITHUB_TOKEN | docker login -u ${GITHUB_ID} --password-stdin ghcr.io >/dev/null 2>&1
    # Pull the image
    docker pull "${adtimage}"
    # Try to clean up dangling images, use a variable to avoid none 0 return
    notuseval=$(docker rmi -f $(docker images -f "dangling=true") >/dev/null 2>&1 || true)
  fi
}

function loginToDockerHub() {
  if [[ ! -z "${GITHUB_ID}" ]] && [[ ! -z "${GITHUB_TOKEN}" ]]; then
    echo -e "${Green}Logging into docker hub...${ColorOff}"
    echo $DH_TOKEN | docker login -u $DH_ID --password-stdin docker.io >/dev/null 2>&1
  fi
}

function checkEnvironmentVariables() {
  envs=(DEPLOY_TYPE VAULT_ADDR GITHUB_USERNAME \
        GITHUB_TOKEN GITHUB_ID CREDS_AUTH_CLIENT_ID \
        CREDS_AUTH_DOMAIN CREDS_ISSUER_URL CLUSTER_ENDPOINT IMAGE_HOST)
  for value in ${envs[@]}; do
    if [[ -z ${!value} ]]; then
      echo -e "${Red}${value}${ColorOff} was not set, quiting..."
      exit 1
    elif [[ "${value}" == "GITHUB_TOKEN" ]] || [[ "${value}" == "CREDS_IMAGE_PASSWORD" ]]; then
      echo -e "${Green}${value}${ColorOff}=************"  
    else
      echo -e "${Green}${value}${ColorOff}=${!value}"
    fi
  done
}

function checkInPolaris() {
    # check that the Makefile and pcloud directory exists
    if [[ ! -f "${CURDIR}/Makefile" ]] || [[ ! -d "${CURDIR}/pcloud" ]]; then
      echo -e "${Red}You are not in Polaris root directory, quiting...${ColorOff}"
      exit 1
    fi
}

function deployDashboard() {
  # Get needed prometheus and grafana docker image
  loginToDockerHub
  dashImages=("prom/prometheus:v2.42.0" "grafana/grafana:9.4.3")
  for item in "${dashImages[@]}"; do
    echo -e "${Green}Pulling image ${item}...${ColorOff}"
    docker pull ${item}
    ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${item}" --context ${CONTEXT}
  done
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/prometheus.yaml
  kubectl --context ${CONTEXT} apply -n $NAMESPACE -f ${HOME}/addon/acs-north-star-dashboards.yaml
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/grafana.yaml
}

kill_port_forward() {
  service=$1
  processes=$(ps -a | grep 'kubectl' | grep 'port-forward' | grep "${service}")
  process_ids=$(echo "${processes}" | cut -d ' ' -f1)
  if [ -n "${process_ids}" ]; then
    echo "${process_ids}" | xargs kill -2 2>&1 > /dev/null
    sleep 3
  fi
  echo -e "${Green}Port-forward for ${service} has stopped. ${ColorOff}"
}

forward_port() {
  service=$1
  ${SCRIPTDIR}/pcloud-port-forward -s "${service}" 2>&1 > /dev/null &
  sleep 3 # takes a few seconds to get started (especially with remote clusters)

  echo -e "${Green}Port-forward for ${service} has started. ${ColorOff}"
}

function wait_for_pod() {
  # Since the billing, trident-svc and bucketservice are the ones become available latest
  # We will just watch them.
  echo -e "${Green}Waiting for pods to be ready...${ColorOff}"
  while : ; do
    if kubectl wait pod --context ${CONTEXT} -n ${NAMESPACE} --for=condition=ready \
      -l 'app.kubernetes.io/name in (billing, trident-svc, bucketservice)' --timeout=120s 2>&1; then
       break
    fi
    sleep 5
  done
  echo -e "${Green}ACS pods are ready now${ColorOff}"
}

ACCOUNTINDEX=1
function saveAccountIndex() {
  content="ACCOUNTINDEX=${ACCOUNTINDEX}"
  echo ${content} > /home/work/astra/accountIndex.sh
}

function loadAccountIndex() {
  if [ -f /home/work/astra/accountIndex.sh ]; then
    source /home/work/astra/accountIndex.sh
  fi
  # If we have used up all the numbers, we should reset
  if [[ ${ACCOUNTINDEX} -ge 100 ]]; then
    ACCOUNTINDEX=1
  fi
}

function initACS() {
  # Get sre token
  wait_for_pod
  forward_port credentials

  # Run setting service accounts
  python3 ${SCRIPTDIR}/serviceaccount.py

  # Now stop the port forwarding
  kill_port_forward credentials
}

function deployAccounts() {

  forward_port krakend
  loadAccountIndex

  # Create 3 accounts each time
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))

  saveAccountIndex

  # Now stop the port forwarding
  kill_port_forward krakend
}

function deployACC() {
  # Get latest astra version
  ASTRA_VERSION=$(${CURDIR}/cicd/scripts/get_latest_version_tag.sh --version-only astra)
  accoptag=$(getServiceTag 'acc-operator')
  echo -e "${Green}Deploying Astra version ${ASTRA_VERSION}...${ColorOff}"

  # acc operator pulls helm chart from a local helm chart repo which needs to be setup
  # using the enterprise-helm-repo image, the tag equals ASTRA_VERSION
  orignalName=${IMAGENAME}
  IMAGENAME="enterprise-helm-repo:${ASTRA_VERSION}"
  pullACImages
  pushACImages

  IMAGENAME="acc-operator:${accoptag}"
  pullACImages
  pushACImages
  IMAGENAME=${orignalName}

  set -
  cd /home/acc

  # Setup netapp-acc-operator
  accopns="netapp-acc-operator"
  # Create the namespace
  kubectl create --context="${CONTEXT}" namespace ${accopns} 2>/dev/null || true

  # Create the certificate
  ${SCRIPTDIR}/k8stool cert --namespace ${accopns} --context ${CONTEXT} --workdir "${WORKDIR}"

  # getting the nginx image:
  docker pull nginx:1.23.4
  docker tag nginx:1.23.4 localhost:5001/nginx:1.23.4
  docker push localhost:5001/nginx:1.23.4

  registryip=$(docker inspect kind-registry --format "{{.NetworkSettings.Networks.kind.IPAddress}}" 2>/dev/null || true)
  if [[ -z "${registryip}" ]]; then
     echo -e "${Red}Local registry is not working, cannot continue${ColorOff}"
     exit 1
  fi
  sed -i "s/KIND_REGISTRY_IP/${registryip}/" nginx.yaml

  # This deployment is to ensure that acc operator happy with the image registry
  # Deploy the service to the namespace
  kubectl apply -n ${accopns} -f nginx.yaml

  # Repair the image tag for acc operator
  imgtag="${IMAGE_HOST}/kube-rbac-proxy:v4.8.0" yq 'select(document_index == 11).spec.template.spec.containers[0].image = env(imgtag)' \
    -i astra_control_center_operator_deploy.yaml
  imgtag="${IMAGE_HOST}/acc-operator:${accoptag}" yq 'select(document_index == 11).spec.template.spec.containers[1].image = env(imgtag)' \
    -i astra_control_center_operator_deploy.yaml

  set +
  # Now run the whole deployment process
  echo -e "${Green}Deploying ACC...${ColorOff}"
  # ${CURDIR}/acc-operator/astractl/astractl deploy --registry "kind-registry:5001" --timeout 300 --astra-version "${ASTRA_VERSION}" \
  #   --ingress-type AccTraefik --astra-resources-scalar "Default" --additional-values \
  #   '{"activity":{"replicas":1},"polaris-mongodb":{"mongodb":{"persistence":{"size":"5Gi"},"replicaCount":1,"image":{"registry":"ghcr.io","tag":"5.0.14","repository":"zcube/bitnami-compat/mongodb"}}},"polaris-consul":{"consul":{"server":{"replicas":1,"bootstrapExpect":1,"storage":"2Gi","resources":{"limits":{"memory":"50Mi"}}}}},"keycloak-operator":{"replicaCount":1},"polaris-keycloak":{"replicaCount":1,"mariadb-galera":{"replicaCount":1}},"features":{"replicas":1,"resources":{"requests":{"cpu":"10m","memory":"40Mi"}}},"loki":{"persistence":{"size":"5Gi"},"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"asup":{"persistence":{"size":"5Gi"},"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"nautilus":{"replicaCount":1,"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"polaris-influxdb2":{"persistence":{"size":"5Gi"},"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"traefik":{"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"task-service":{"resources":{"requests":{"cpu":"10m","memory":"10Mi"}}},"nats":{"replicaCount":1},"polaris-vault":{"vault":{"server":{"ha":{"replicas":1},"auditStorage":{"size":"2Gi"}}}},"certificates":{"replicas":1},"credentials":{"replicas":1},"krakend":{"replicas":1},"openapi":{"replicas":1},"vault-controller":{"replicas":1},"cert-manager":{"cert-manager":{"replicaCount":1,"webhook":{"replicaCount":1},"cainjector":{"replicaCount":1}}}}'
  
  # Now deploy acc operator first
  kubectl apply --context ${CONTEXT} -n ${accopns} -f astra_control_center_operator_deploy.yaml

  # Now fix up the astra version
  astraVersion="${ASTRA_VERSION}" yq '.spec.astraVersion = env(astraVersion)' -i acc.yaml

  # Deploy astra control center
  kubectl create --context="${CONTEXT}" namespace ${NAMESPACE} 2>/dev/null || true
  kubectl apply --context="${CONTEXT}" -n ${NAMESPACE} -f acc.yaml

  # Wait for the polaris-ui pod to become ready, this can be a long wait.
  echo -e "Waiting for polaris to become ready..."
  startTime=$(date +%s)
  while : ; do
    updateKeycloakOperatorSetting
    res=$(kubectl wait --context "${CONTEXT}" -n ${NAMESPACE} pod \
      -l "app.kubernetes.io/name=polaris-ui" --for=condition=Ready --timeout=30s 2>/dev/null ||true)
    if [[ "${res}" == *"condition met"* ]]; then
      break
    fi
    currentTime=$(date +%s)
    elapsed=$(( currentTime - startTime ))
    echo -ne "\033[0K\r"
    echo -ne "   Time elapsed: ${Green}${elapsed}${ColorOff} seconds\033[0K"
    sleep 30
  done

  set -

  # Setup the proxy
  echo ""
  echo -e "${Green}Creating path to access ACC...${ColorOff}"
  ${SCRIPTDIR}/k8stool proxy --targetports "traefik 80 443" --workdir "${WORKDIR}" --context ${CONTEXT}

  # Get the user name and password for login
  loginpw=$(kubectl get astracontrolcenters.astra.netapp.io -n ${NAMESPACE} -o jsonpath='ACC-{..uid}')
  echo -e "${Green}Astra Control Center has been successfully setup${ColorOff}"
  echo -e "Use the following to login"
  echo -e "   Email: ${Green}admin@integration.astra.netapp.io${ColorOff}"
  echo -e "   Password: ${Green}${loginpw}${ColorOff}"
}
  
function fixcertificateimage() {
  # this method pulls the certificate image I fixed and use it for development
  echo $GITHUB_TOKEN | docker login -u ${GITHUB_ID} --password-stdin ghcr.io >/dev/null 2>&1
  docker pull ghcr.io/netapp-polaris/polaris/astra/certificates:astradt
  tag=$(getServiceTag certificates)
  docker tag ghcr.io/netapp-polaris/polaris/astra/certificates:astradt "certificates:${tag}"
  docker tag ghcr.io/netapp-polaris/polaris/astra/certificates:astradt "localhost:5001/certificates:${tag}"
}

function updateKeycloakOperatorSetting() {
  # This function will update the keycloak operator two hidden env to be 1
  # If the operator is ready, it will update, otherwise, it will do nothing.
  res=$(kubectl wait --context "${CONTEXT}" -n ${NAMESPACE} pod \
    -l "app.kubernetes.io/name=keycloak-operator" --for=condition=Ready --timeout=30s 2>/dev/null ||true)
  if [[ "${res}" == *"condition met"* ]]; then
    # It is ready, we need to apply the patch to it now.
    kubectl set env --context "${CONTEXT}" -n "${NAMESPACE}" deployment/keycloak-operator \
      KCOP_KEYCLOAK_REPLICAS=1 KCOP_KEYCLOAK_DBREPLICAS=1 2>/dev/null
  fi
}

function thebackup() {
  set -
  cd /home/acc

  imgtag="${IMAGE_HOST}/kube-rbac-proxy:v4.8.0" yq '.spec.template.spec.containers[0].image = env(imgtag)' -i part2_op_deploy.yaml
  imgtag="${IMAGE_HOST}/acc-operator:${accoptag}" yq '.spec.template.spec.containers[1].image = env(imgtag)' -i part2_op_deploy.yaml

  # Ensure ACC operator namespace exists
  ACCOPNAMESPACE="netapp-acc-operator"
  kubectl create --context="${CONTEXT}" namespace ${ACCOPNAMESPACE} --dry-run=client -o yaml \
    | kubectl apply --context="${CONTEXT}" -f -

  # Here we need to setup a service and endpoint so that the stupid acc operator can do crazy stuff
  registryip=$(docker inspect kind-registry --format "{{.NetworkSettings.Networks.kind.IPAddress}}" 2>/dev/null || true)
  if [[ -z "${registryip}" ]]; then
     echo -e "${Red}Local registry is not working, cannot continue${ColorOff}"
     exit 1
  fi

  registryip="${registryip}" yq 'select(document_index == 1).subsets[0].addresses[0].ip = env(registryip)' -i registry-service.yaml

  # now we create a secret to save the tls certs
  ${SCRIPTDIR}/k8stool cert --namespace ${ACCOPNAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"

  kubectl --context ${CONTEXT} apply -n ${ACCOPNAMESPACE} -f registry-service.yaml

  # Deploy service account, roles, configmaps
  kubectl --context ${CONTEXT} apply -n ${ACCOPNAMESPACE} -f part1_op_deploy.yaml
  # Now Deploy ACC operator
  kubectl --context ${CONTEXT} apply -n ${ACCOPNAMESPACE} -f part2_op_deploy.yaml

  # Ensure astra control center namespace exists
  kubectl create --context="${CONTEXT}" namespace ${NAMESPACE} --dry-run=client -o yaml \
    | kubectl apply --context="${CONTEXT}" -f -
  ASTRA_VERSION=$ASTRA_VERSION yq '.spec.astraVersion = env(ASTRA_VERSION)' -i /home/acc/acc.yaml
  REGISTRY_NAME="${IMAGE_HOST}" yq '.spec.imageRegistry.name = env(REGISTRY_NAME)' -i /home/acc/acc.yaml

  # Deploy Astra control center
  kubectl --context ${CONTEXT} apply -n ${NAMESPACE} -f /home/acc/acc.yaml

  cd ${CURDIR}
  set +
}

function deployAC() {
  CNAME=$1
  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "traefik" ]]; then
    rm -rf /home/polaris/build
    echo -e "${Green}Ready to deploy traefik${ColorOff}"
    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true \
    make traefikinstall DEPLOY_TARGET=local \
    CLUSTER_ENDPOINT=integration.astra.netapp.io \
    TRAEFIK_ENDPOINT=integration.astra.netapp.io NAMESPACE=${NAMESPACE}

    # Only setup proxy when doing things locally.
    if [[ ${CLUSTER_ENDPOINT} == "integration.astra.netapp.io" ]]; then
      echo -e "${Green}Setting up proxy...${ColorOff}"
      ${SCRIPTDIR}/k8stool proxy --targetports "traefik 80 443" --workdir "${WORKDIR}" --context ${CONTEXT}
    fi
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "main" ]]; then
    rm -rf /home/polaris/build
    echo -e "${Green}Ready to deploy Astra${ColorOff}"

    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true IMAGE_HOST=${IMAGE_HOST} \
    make helminstall DEPLOY_TARGET=cicd NAUTILUS_REPLICAS=1 \
    CLUSTER_ENDPOINT=integration.astra.netapp.io \
    TRAEFIK_ENDPOINT=integration.astra.netapp.io \
    HELMOVERRIDE='--set mongodb.image.registry=ghcr.io --set mongodb.image.repository=zcube/bitnami-compat/mongodb --set mongodb.image.tag=5.0.14 --set mongodb.replicaCount=1'

    # For now remove the services/deployments that not needed
    kubectl delete --context ${CONTEXT} -n ${NAMESPACE} deployment natssync-server httpproxy-server hybridauth 2>/dev/null||true
    kubectl delete --context ${CONTEXT} -n ${NAMESPACE} service natssync-server httpproxy-server hybridauth 2>/dev/null||true
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "dash" ]]; then
    echo -e "${Green}Deploy dashboard...${ColorOff}"
    deployDashboard
  fi

  # This has to be done always, no need to run again if successful
  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "service" ]]; then
    echo -e "${Green}Setting up service accounts...${ColorOff}"
    initACS
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "user" ]]; then
    echo -e "${Green}Setting up user accounts...${ColorOff}"
    deployAccounts
  fi
}

function pullAndTag() {
  iname=$1
  itag=$2
  echo -e "   Processing ${iname}:${itag}"
  anImage=$(docker images "localhost:5001/${iname}:${itag}" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
  # The image already exists locally, do not need to pull
  if [[ -z "${anImage}" ]]; then
    docker pull "${IMAGE_REPOSITORY}/${iname}:${itag}"
    docker tag "${IMAGE_REPOSITORY}/${iname}:${itag}" "localhost:5001/${iname}:${itag}"
  else
    echo -e "   ${Green}Already exists locally, skipping${ColorOff}"
  fi
}

declare -A allimages
# allimages=(['ghcr.io/zcube/bitnami-compat/mongodb:5.0.14']='d' ['nk:v0.1.0']='' ['kube-rbac-proxy:v4.8.0']='')
allimages=()
function saveAllImageTags() {
  cid=$(git rev-parse --short HEAD)
  echo -e "${Green}Current commit ${cid}${ColorOff}"
  content="allimages=("
  for imagename in "${!allimages[@]}"; do
    content="${content} ['"${imagename}"']='"${allimages[$imagename]}"'"
  done
  content="${content})"
  echo ${content} > /home/work/astra/${cid}.sh
}

function loadAllImageTags() {
  cid=$(git rev-parse --short HEAD)
  echo -e "${Green}Current commit ${cid}${ColorOff}"
  if [ -f /home/work/astra/${cid}.sh ]; then
    echo -e "${Green}Commit level did not change, loading the saved the image tags...${ColorOff}"
    source /home/work/astra/${cid}.sh
  fi
}

function getServiceTag() {
  release_name=$1
  tags=$(git tag -l "release/${release_name}/*-integration" --sort=-version:refname --merged | head -n 1)
  
  if [ -z "${tags}" ]; then
    echo ""
  else
    for tag in ${tags}; do
      version=$(echo "${tag}" | sed 's,/,\n,g' | tail -1)
      echo "${version}"
    done
  fi
}


# This function will parse the ACC master image list and create a list
# of the images needed to deploy ACC
function getACExternalImages() {
  # Use jq to parse the external-services.json file and get a string list like this.
  #
  #    "nk:v0.1.0"
  #    "quay.io/jetstack/cert-manager-controller:v1.11.0"
  #    "quay.io/jetstack/cert-manager-webhook:v1.11.0"
  #    "quay.io/jetstack/cert-manager-cainjector:v1.11.0"
  #    "quay.io/jetstack/cert-manager-ctl:v1.11.0"

  # Get from the service json file and remove things not necessory or does not even exist on globalcicd
  # This removed some not used ones
  # accExtImages=$(cat ${CURDIR}/enterprise/external-services.json | jq '.services' |
  #   jq 'map(."container-images") | flatten | unique |
  #      del(..|select(. =="bitnami/mongodb-exporter:0.33.0-debian-11-r9")) | del(..|select(. =="bitnami/mongodb:5.0.10-debian-11-r3"))' |
  #   jq '.[]')

  # Get all external images needed
  accExtImages=$(cat ${CURDIR}/enterprise/external-services.json | jq '.services' |
    jq 'map(."container-images") | flatten | unique' | jq '.[]')

  if [[ ${#accExtImages[@]} == 0 ]]; then
    echo -e "${Red}No external image found, this is an error, quiting...${ColorOff}"
    exit 1
  fi

  # We try to login to docker hub for images not available on netapp repo
  loginToDockerHub

  # Since the mongodb is special, we have to add it here
  accExtImages+=("ghcr.io/zcube/bitnami-compat/mongodb:5.0.14")

  for anItem in ${accExtImages[@]}; do
    # Strip the quotes if there are any
    anItem="${anItem%\"}"; anItem="${anItem#\"}"
    anImage=$(echo ${anItem} | rev | cut -d '/' -f 1|rev)

    echo -e "Processing ${Green}${anItem}${ColorOff}"
    theImage=$(docker images "localhost:5001/${anImage}" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
    # The image already exists locally, do not need to pull
    if [[ -z "${theImage}" ]]; then
      # Pulling the image from its defined location)
      pullok=$(docker pull "${anItem}" 2>/dev/null || true)
      if [[ -z ${pullok} ]]; then
        # The repo does not have the image, try the public one
        docker pull "${IMAGE_REPOSITORY}/${anImage}"
        docker tag "${IMAGE_REPOSITORY}/${anImage}" "localhost:5001/${anImage}"
        docker tag "${IMAGE_REPOSITORY}/${anImage}" "${anItem}"
      else
        # Tag the image with no registry for development purpose, probably do not need to do this
        docker tag "${anItem}" "${anImage}"
        # Tag the image with localhost
        docker tag "${anItem}" "localhost:5001/${anImage}"
      fi
    else
      echo -e "   ${Green}Already exists locally, skipping pulling${ColorOff}"
    fi
    # We need to push the image in case that the registry was removed
    # We may need to verify first before push
    if [[ "${TYPE}" == "acs" ]]; then
      # For acs, these external images need to be pushed to each node to avoid pulling limit issues.
      # We could choose to not push at all. This list should be reduced to must have external images
      docker tag "localhost:5001/${anImage}" "${anItem}"
      kind load docker-image -n astra "${anItem}"
    else
      docker push "localhost:5001/${anImage}"
    fi
  done
}

function getAllImages() {
  echo -e "${Green}Calculating image tags based on current commit level...${ColorOff}"
  for key in "${!ACSIMAGES[@]}"; do
    val="${ACSIMAGES[$key]}"
    comp="${key}"
    if [[ ! -z "${val}" ]]; then
      comp="${val}"
    fi
    tag=$(getServiceTag ${comp})
    imagename="${key}:${tag}"
    echo "   ${imagename}"
    allimages[$imagename]=''
  done
  saveAllImageTags
}

function pullAstraComponentImage() {
  imagename=$1
  imageparts=(${imagename//:/ })
  name=${imageparts[0]}
  tag=${imageparts[1]}
  echo -e "${Green}Pulling Astra Control image ${imagename}${ColorOff}"
  pullAndTag ${name} ${tag}
}

function pullACImages() {
  # repologin="https://${IMAGE_REPOSITORY}/v2/"
  # response=$(docker login -u ${CREDS_IMAGE_USERNAME} -p ${CREDS_IMAGE_PASSWORD} ${IMAGE_REPOSITORY})
  loginToDockerHub
  if [[ "${IMAGENAME}" == "" ]]; then
    loadAllImageTags
    size=$(echo ${#allimages[@]})
    if [ "$size" -lt "1" ]; then
      getAllImages
    fi
    echo -e "${Green}Start pulling Astra images...${ColorOff}"
    for imagename in "${!allimages[@]}"; do
      pullAstraComponentImage "${imagename}"
    done
  else
    pullAstraComponentImage "${IMAGENAME}"
  fi
}

# pushAstraComponentImage only pushes image to the local
# image repository.
function pushAstraComponentImage() {
  imagename=$1
  imageparts=(${imagename//:/ })
  name=${imageparts[0]}
  tag=${imageparts[1]}
  echo -e "${Green}Ready to push ${imagename}${ColorOff}"
  docker push "localhost:5001/${imagename}"  
}

function pushACImages() {
  # repologin="https://${IMAGE_REPOSITORY}/v2/"
  # response=$(docker login -u ${CREDS_IMAGE_USERNAME} -p ${CREDS_IMAGE_PASSWORD} ${IMAGE_REPOSITORY})
  if [[ "${IMAGENAME}" == "" ]]; then
    fixcertificateimage
    size=$(echo ${#allimages[@]})
    if [ "$size" -lt "1" ]; then
      getAllImages
    fi
    echo -e "${Green}Pushing images...${ColorOff}"
    for imagename in "${!allimages[@]}"; do
      pushAstraComponentImage "${imagename}"
    done
  else
    pushAstraComponentImage "${IMAGENAME}"
  fi
}

function refreshDeployment() {
  if [[ "${DEPLOYMENT}" == "" ]]; then
    echo -e "${Red}Use -d parameter to specify a deployment to be refreshed${ColorOff}"
    exit 1
  else
    OLDIFS=$IFS
    dep=$(kubectl --context ${CONTEXT} get -n ${NAMESPACE} deployment "${DEPLOYMENT}" -o \
      jsonpath='{.spec.template.spec.containers[*].image}' 2>/dev/null||true)
    if [[ "${dep}" == "" ]]; then
      echo -e "${Red}Could not find the deployment ${DEPLOYMENT}${ColorOff}"
      IFS=$OLDIFS
      exit 1
    else
      # Now need to get the tag and the actual image name
      IFS=$'/' parts=($(echo "${dep}"|rev))
      imagename=$(echo "${parts[0]}"|rev)
      IFS=$OLDIFS
      if [[ "${imagename}" != "" ]]; then
        echo "Ready to update ${imagename}"
        if [[ "${dep}" =~ "${IMAGE_HOST}" ]]; then
          # astra image, push the newer image
          ${SCRIPTDIR}/k8stool image --source-tag "${imagename}"
          # Remove the cached image
          docker exec astra-control-plane crictl rmi "${dep}" 2>/dev/null || true
        else
          # other images
          ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${imagename}"
        fi
        kubectl --context ${CONTEXT} rollout restart -n ${NAMESPACE} deployment ${DEPLOYMENT}
      fi
    fi
  fi
}


function setupTrident() {
  set +e
  tridentns="trident"
  kubectl get namespace ${tridentns} --context "${CONTEXT}" >/dev/null 2>&1
  # namespace does not exist, create it
  if [[ $? == 1 ]]; then
    echo "Creating namespace ${tridentns}"
    set -e
    kubectl create ns ${tridentns} --context "${CONTEXT}"
  else
    echo "Namespace ${tridentns} already exists"
  fi
  set -e

  # Getting trident images
  tridentImages=("netapp/trident:23.01.1" "netapp/trident-autosupport:23.01" "netapp/trident-operator:23.01.1" \
    "registry.k8s.io/sig-storage/csi-provisioner:v3.4.0" "registry.k8s.io/sig-storage/csi-attacher:v4.1.0" \
    "registry.k8s.io/sig-storage/csi-resizer:v1.7.0" "registry.k8s.io/sig-storage/csi-snapshotter:v3.0.3" \
    "registry.k8s.io/sig-storage/csi-node-driver-registrar:v2.7.0")

  for item in ${tridentImages[@]}; do
    echo -e "${Green}Pulling image ${item}...${ColorOff}"
    docker pull --platform=linux/amd64 ${item}
    ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${item}" --context ${CONTEXT}
  done

  echo -e "${Green}Deploying trident onto kubernetes cluster...${ColorOff}"
  kubectl --context "${CONTEXT}" apply -f /home/trident/tridentorchestrator.yaml -n ${tridentns}
  echo "Trident CRDs are deployed"
  ARCH=$(uname -m) && if [[ "${ARCH}" == "aarch64" ]]; then ARCH=arm64; fi
  if [[ "${ARCH}" == "x86_64" ]]; then ARCH="amd64"; fi

  # Now make sure that the node using right architecture node label
  ARCH=$ARCH yq e '.spec.controllerPluginNodeSelector."kubernetes.io/arch" = env(ARCH)' -i /home/trident/tridentorchestrator_cr.yaml
  ARCH=$ARCH yq e '.spec.nodePluginNodeSelector."kubernetes.io/arch" = env(ARCH)' -i /home/trident/tridentorchestrator_cr.yaml

  # Deploy the orchestrator
  kubectl --context ${CONTEXT} apply -f /home/trident/tridentorchestrator_cr.yaml -n ${tridentns}
}

#=================Start main process=========================

set -e
# cluster processes
if [[ "${CMD}" == "up" ]]; then
  echo ""
  checkInPolaris
  checkEnvironmentVariables

  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  if [[ "${TYPE}" == "acc" ]]; then
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}" -w 2
  else
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  fi
  echo -e "${Green}Upload Astra images to image repostiory"
  validateContext

  echo ""
  echo -e "${Green}Process required external images...${ColorOff}"
  getACExternalImages
  
  echo -e "${Green}Process astra images...${ColorOff}"
  pullACImages
  echo ""
  pushACImages

  if [[ "${TYPE}" == "acc" ]]; then
    setupTrident
    deployACC
  else
    echo -e "${Green}Create traefik certificate${ColorOff}"
    ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
    deployAC "${COMPONENT}"
  fi

elif [[ "${CMD}" == "prepare" ]]; then
  echo ""
  checkInPolaris
  checkEnvironmentVariables

  echo ""
  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  if [[ "${TYPE}" == "acc" ]]; then
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}" -w 2
  else
    ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  fi
  echo -e "${Green}Upload Astra images to image repostiory"
  validateContext
  echo ""
  # Process external images needed
  echo -e "${Green}Process required external images...${ColorOff}"
  getACExternalImages
  
  echo -e "${Green}Process astra images...${ColorOff}"
  pullACImages
  echo ""
  pushACImages

  if [[ "${TYPE}" == "acc" ]]; then
    setupTrident
  fi

  # echo -e "${Green}Create traefik certificate${ColorOff}"
  # ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  # echo -e "${Green}Ready to deploy Astra, please run deploy command${ColorOff}"

elif [[ "${CMD}" == "down" ]]; then
  echo ""
  echo -e "${Green}Removing Astra main components...${ColorOff}"
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  if [[ "${TYPE}" == "acs" ]]; then
    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true \
      make helmuninstall DEPLOY_TARGET=cicd
  else
    kubectl --context ${CONTEXT} delete -n pcloud astracontrolcenter astra
    kubectl --context ${CONTEXT} delete namespace netapp-acc-operator pcloud
  fi

elif [[ "${CMD}" == "clean" ]]; then
  echo -e "${Green}Removing Astra and cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d

elif [[ "${CMD}" == "cleanall" ]]; then
  echo -e "${Green}Removing everything...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d
  # Remove the proxy and the local registry as well
  docker rm -f kubeproxy &> /dev/null || true
  docker rm -f kind-registry &> /dev/null || true
  # Need to clean up docker volumes
  docker volume prune -f &> /dev/null || true
  rm -rf /home/work/astra/*.sh

elif [[ "${CMD}" == "image" ]]; then
  validateContext
  checkInPolaris
  checkEnvironmentVariables
  if [[ "${IMAGENAME}" == "" ]]; then
    getACExternalImages
  fi
  pullACImages
  pushACImages

elif [[ "${CMD}" == "pull" ]]; then
  validateContext
  checkInPolaris
  checkEnvironmentVariables
  if [[ "${IMAGENAME}" == "" ]]; then
    getACExternalImages
  fi
  pullACImages
  pushACImages

elif [[ "${CMD}" == "deploy" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  # Always check and recreate namespace and the cert in case it was removed
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  if [[ "${TYPE}" == "acs" ]]; then
    deployAC "${COMPONENT}"
  else
    deployACC
  fi

elif [[ "${CMD}" == "refresh" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  refreshDeployment

elif [[ "${CMD}" == "trident" ]]; then
  validateContext
  loginToDockerHub
  setupTrident

elif [[ "${CMD}" == "update" ]]; then
  checkEnvironmentVariables
  doADTUpdate

elif [[ "${CMD}" == "make" ]]; then
  loginToDockerHub
  make ${REST}

elif [[ "${CMD}" == "k8stool" ]]; then
  echo ""
  echo -e "${Green}Running k8stool commands...${ColorOff}"
  ${SCRIPTDIR}/k8stool ${REST}

fi
#=================End main process=========================
