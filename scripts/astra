#!/bin/bash

ColorOff='\033[0m'        # Text Reset
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
SCRIPTDIR=$(dirname $0)
APPNAME=$(basename "$0")
CURDIR=$(pwd)
WORKDIR=${WORKDIR:-/tmp/astra}
COMPONENT="all"
NAMESPACE="${NAMESPACE:-pcloud}"
IMAGE_REPOSITORY=${IMAGE_REPOSITORY:-docker.repo.eng.netapp.com}
CLUSTER_ENDPOINT=${CLUSTER_ENDPOINT:-integration.astra.netapp.io}
IMAGENAME=""


declare -A ACSIMAGES
ACSIMAGES=(['activity']='' ['astra-py-k8s']='' ['billing']='' ['bucketservice']='' \
  ['cloud-extension']='' ['composite-compute']='' ['composite-volume']='' ['credentials']='' \
  ['entitlement']='' ['features_init']='features' ['features']='' ['features_upgrade']='features' \
  ['graphql-server']='' ['hybridauth']='' ['identity']='' ['krakend']='' ['nautilus']='' ['openapi']='' ['polaris-ui']='' \
  ['support']='' ['support_hourly']='support' ['support_weekly']='support' ['task-service']='' \
  ['task-service_task_purge']='task-service' ['tenancy']='' ['tenancy_account_purge']='tenancy' \
  ['trident-svc']='' ['nats']='d' ['theotw/natssync-server']='d' ['theotw/httpproxy-server']='d' \
  ['traefik']='d' ['hashicorp/vault']='d')

declare -A TAGPATH
TAGPATH=(['astra-py-k8s']='.initContainer.image.tag' ['theotw/natssync-server']='.image.tag' \
  ['theotw/httpproxy-server']='.image.tag' ['traefik']='.traefik.image.tag' \
  ['nats']='.appVersion' ['hashicorp/vault']='.vault.server.image.tag')

declare -A TAGYAML
TAGYAML=(['astra-py-k8s']='activity/values.yaml' ['theotw/natssync-server']='natssync-server/values.yaml' \
  ['theotw/httpproxy-server']='httpproxy-server/values.yaml' ['traefik']='traefik/values.yaml' \
  ['nats']='nats/Chart.yaml' ['hashicorp/vault']='polaris-vault/values.yaml')

function printHelp() {
  echo ""
  echo "Usage:"
  echo "    ${APPNAME} <cmd> [options]"
  echo ""
  echo -e "Available commands:"
  echo "     up       - Start up astra network include cluster"
  echo "     down     - Remove all astra but k8s cluster"
  echo "     image    - Update image to the local repo"
  echo "     prepare  - Get cluster and image ready"
  echo "     deploy   - Deploy astra components"
  echo "     clean    - Remove all astra including k8s cluster"
  echo "     cleanall - Remove all astra including k8s cluster, proxy, local registry"
  echo "     pull     - pull tagged commit image from repo"
  echo "     update   - update this tool"
  echo "     refresh  - restart a deployment and its image"
  echo "     make     - run polaris make command"
  echo ""
  echo -e "Parameters for ${Green}image${ColorOff} command:"
  echo "     -i|--imagename  - an astra image name. default is all images"
  echo ""
  echo -e "Parameters for ${Green}pull${ColorOff} command:"
  echo "     -i|--imagename   - an astra image name. default is all images"
  echo ""
  echo -e "Parameters for ${Green}deploy${ColorOff} command:"
  echo "     -a|--astra-name) - a name of astra component to be deployed. Valid option"
  echo "                        are all, main, traefik, post, dash default is all"
  echo "        --context)    - a kubernetes context to use, if not specified, the"
  echo "                        current kubernetes context will be used"
  echo ""
  echo -e "Parameters for ${Green}refresh${ColorOff} command:"
  echo "     -d|--deployment-name  - a deployment name such as identity"
  echo "     -n|--namespace        - the namespace where the deployment is, default pcloud"
  echo "        --context)         - a kubernetes context to use, if not specified, the"
  echo "                             current kubernetes context will be used"
  echo ""
}

function validateCMD() {
  cmd=$1
  allCommands=("up" "down" "image" "deploy" "clean" "cleanall" "prepare" "pull" "refresh" "make" "update")
  ccmd=""
  for item in "${allCommands[@]}"; do
    if [[ "${cmd}" == "${item}" ]]; then
      ccmd="${cmd}"
      isValidCMD="true"
      break
    fi
  done
  if [[ -z "${ccmd}" ]]; then
    if [[ "${cmd}" != "-h" ]] && [[ "${cmd}" != "--help" ]] && [[ "${cmd}" != "" ]]; then
      echo ""
      echo -e "ERROR: ${Red}${cmd}${ColorOff} is not a supported command!"
      printHelp "${isValidCMD}"
      exit 1
    else
      printHelp "${isValidCMD}"
      exit 0
    fi
  fi
}

CMD=$1
shift
# This saves the rest of the command in case it is to pass along for make command
REST="$@"
# Validate the command
validateCMD "${CMD}"

# We will only handle command parameters if command was not make
if [[ "${CMD}" != "make" ]]; then
  # Handling parameters
  while [[ $# -gt 0 ]]; do
    optkey="$1"
    case $optkey in
      -h|--help)
        printHelp "true"; exit 0;;
      --context)
        CONTEXT="$2";shift 2;;
      --targetports)
        TARGETPORTS="$2";shift 2;;
      -n|--namespace)
        NAMESPACE="$2";shift 2;;
      -w|--workdir)
        WORKDIR="$2";shift 2;;
      -a|--astra-name)
        COMPONENT="$2";shift 2;;
      -d|--deployment-name)
        DEPLOYMENT="$2";shift 2;;
      -i|--imagename)
        IMAGENAME="$2";shift 2;;
      *) # unknown option
        echo "parameter $1 is not supported"; exit 1;;
    esac
  done
fi

function validateContext() {
  # Context was not set, trying to use current context
  if [[ -z "${CONTEXT}" ]]; then
    # Get current context
    ctx=$(kubectl config current-context 2>/dev/null || true)
  else # Context was set, verify it exists in the kubernetes context
    ctx=$(kubectl config get-contexts "${CONTEXT}" -o=name 2>/dev/null || true)
  fi

  if [[ -z "${ctx}" ]]; then
    echo -e "${Red}No kubernetes context available, cannot continue${ColorOff}"
    exit 1
  fi

  CONTEXT="${ctx}"
}

function doADTUpdate() {
  adtimage=$(docker inspect astra --format "{{.Config.Image}}" 2>/dev/null || true)
  if [[ ! -z "${adtimage}" ]]; then
    # Using the github token and id to login
    echo $GITHUB_TOKEN | docker login -u ${GITHUB_ID} --password-stdin ghcr.io >/dev/null 2>&1
    # Pull the image
    docker pull "${adtimage}"
    # Try to clean up dangling images, use a variable to avoid none 0 return
    notuseval=$(docker rmi -f $(docker images -f "dangling=true") >/dev/null 2>&1 || true)
  fi
}

function loginToDockerHub() {
  if [[ ! -z "${DH_ID}" ]] && [[ ! -z "${DH_TOKEN}" ]]; then
    echo -e "${Green}Logging into docker hub...${ColorOff}"
    echo $DH_TOKEN | docker login -u $DH_ID --password-stdin docker.io >/dev/null 2>&1
  fi
}

function checkEnvironmentVariables() {
  envs=(DEPLOY_TYPE VAULT_ADDR GITHUB_USERNAME \
        GITHUB_TOKEN GITHUB_ID CREDS_AUTH_CLIENT_ID \
        CREDS_AUTH_DOMAIN CREDS_ISSUER_URL CLUSTER_ENDPOINT)
  for value in ${envs[@]}; do
    if [[ -z ${!value} ]]; then
      echo -e "${Red}${value}${ColorOff} was not set, quiting..."
      exit 1
    elif [[ "${value}" == "GITHUB_TOKEN" ]] || [[ "${value}" == "CREDS_IMAGE_PASSWORD" ]]; then
      echo -e "${Green}${value}${ColorOff}=************"  
    else
      echo -e "${Green}${value}${ColorOff}=${!value}"
    fi
  done
}

function checkInPolaris() {
    # check that the Makefile and pcloud directory exists
    if [[ ! -f "${CURDIR}/Makefile" ]] || [[ ! -d "${CURDIR}/pcloud" ]]; then
      echo -e "${Red}You are not in Polaris root directory, quiting...${ColorOff}"
      exit 1
    fi
}

function deployDashboard() {
  # Get needed prometheus and grafana docker image
  loginToDockerHub
  dashImages=("prom/prometheus:v2.42.0" "grafana/grafana:9.4.3")
  for item in "${dashImages[@]}"; do
    echo -e "${Green}Pulling image ${item}...${ColorOff}"
    docker pull ${item}
    ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${item}" --context ${CONTEXT}
  done
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/prometheus.yaml
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/acs-grafana-dashboards.yaml
  kubectl --context ${CONTEXT} apply -f ${HOME}/addon/grafana.yaml
}

kill_port_forward() {
  ${CURDIR}/scripts/beta/kill_port_forward.sh "$1" 2>&1 > /dev/null &
  echo -e "${Green}Port-forward for ${service} is off. ${ColorOff}"
}

forward_port() {
  service=$1
  ${SCRIPTDIR}/pcloud-port-forward -s "${service}" 2>&1 > /dev/null &
  sleep 5 # takes a few seconds to get started (especially with remote clusters)

  echo -e "${Green}Port-forward for ${service} is on. ${ColorOff}"
}

function wait_for_pod() {
  # Since the billing, trident-svc and bucketservice are the ones become available latest
  # We will just watch them.
  echo -e "${Green}Waiting for pods to be ready...${ColorOff}"
  while : ; do
    if kubectl wait pod --context ${CONTEXT} -n ${NAMESPACE} --for=condition=ready \
      -l 'app.kubernetes.io/name in (billing, trident-svc, bucketservice)' --timeout=120s 2>&1; then
       break
    fi
    sleep 5
  done
  echo -e "${Green}ACS pods are ready now${ColorOff}"
}

ACCOUNTINDEX=1
function saveAccountIndex() {
  content="ACCOUNTINDEX=${ACCOUNTINDEX}"
  echo -e "${Green}Saving account index...${ColorOff}"
  echo ${content} > /home/work/astra/accountIndex.sh
}

function loadAccountIndex() {
  echo -e "${Green}Load account index${ColorOff}"
  if [ -f /home/work/astra/accountIndex.sh ]; then
    echo -e "${Green}Loading the accountIndex...${ColorOff}"
    source /home/work/astra/accountIndex.sh
  fi
  # If we have used up all the numbers, we should reset
  if [[ ${ACCOUNTINDEX} -ge 100 ]]; then
    ACCOUNTINDEX=1
  fi
}

function initACS() {
  # Get sre token
  wait_for_pod
  forward_port credentials

  # Run setting service accounts
  python3 ${SCRIPTDIR}/serviceaccount.py

  # Now stop the port forwarding
  kill_port_forward credentials
}

function deployAccounts() {
  loadAccountIndex
  forward_port krakend
  forward_port identity

  # Create 3 accounts each time
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))
  python3 ${SCRIPTDIR}/postsetup.py ${ACCOUNTINDEX}
  ACCOUNTINDEX=$(( $ACCOUNTINDEX + 1 ))

  saveAccountIndex

  # Now stop the port forwarding
  kill_port_forward krakend
  kill_port_forward identity
}

function deployAC() {
  CNAME=$1
  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "traefik" ]]; then
    echo -e "${Green}Ready to deploy traefik${ColorOff}"
    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true \
    make traefikinstall DEPLOY_TARGET=local \
    CLUSTER_ENDPOINT=integration.astra.netapp.io \
    TRAEFIK_ENDPOINT=integration.astra.netapp.io NAMESPACE=${NAMESPACE}

    # Only setup proxy when doing things locally.
    if [[ ${CLUSTER_ENDPOINT} == "integration.astra.netapp.io" ]]; then
      echo -e "${Green}Setting up proxy...${ColorOff}"
      ${SCRIPTDIR}/k8stool proxy --targetports "traefik 80 443" --workdir "${WORKDIR}" --context ${CONTEXT}
    fi
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "main" ]]; then
    echo -e "${Green}Ready to deploy Astra${ColorOff}"
    KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true IMAGE_HOST=${IMAGE_HOST} \
    make helminstall DEPLOY_TARGET=cicd \
    CLUSTER_ENDPOINT=integration.astra.netapp.io \
    TRAEFIK_ENDPOINT=integration.astra.netapp.io \
    HELMOVERRIDE='--set mongodb.image.repository=zcube/bitnami-compat-mongodb --set mongodb.image.tag=5.0.14 --set mongodb.replicaCount=1'
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "dash" ]]; then
    echo -e "${Green}Deploy dashboard...${ColorOff}"
    deployDashboard
  fi

  # This has to be done always, no need to run again if successful
  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "service" ]]; then
    echo -e "${Green}Setting up service accounts...${ColorOff}"
    initACS
  fi

  if [[ "${CNAME}" == "all" ]] || [[ "${CNAME}" == "user" ]]; then
    echo -e "${Green}Setting up user accounts...${ColorOff}"
    deployAccounts
  fi

}

function pullAndTag() {
  irepo=$1
  iname=$2
  itag=$3
  echo -e "   Processing ${irepo}${iname}:${itag}"
  anImage=$(docker images "${iname}:${itag}" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
  # The image already exists locally, do not need to pull
  if [[ -z "${anImage}" ]]; then
    docker pull "${irepo}${iname}:${itag}"
    docker tag "${irepo}${iname}:${itag}" "${iname}:${itag}"
  else
    echo -e "   ${Green}Already exists locally, skipping${ColorOff}"
  fi
}

declare -A allimages
allimages=(['zcube/bitnami-compat-mongodb:5.0.14']='d')
function saveAllImageTags() {
  cid=$(git rev-parse --short HEAD)
  echo -e "${Green}Current commit ${cid}${ColorOff}"
  content="allimages=("
  for imagename in "${!allimages[@]}"; do
    content="${content} ['"${imagename}"']='"${allimages[$imagename]}"'"
  done
  content="${content})"
  echo ${content} > /home/work/astra/${cid}.sh
}

function loadAllImageTags() {
  cid=$(git rev-parse --short HEAD)
  echo -e "${Green}Current commit ${cid}${ColorOff}"
  if [ -f /home/work/astra/${cid}.sh ]; then
    echo -e "${Green}Commit level did not change, loading the saved the image tags...${ColorOff}"
    source /home/work/astra/${cid}.sh
  fi
}

function getAllImages() {
  echo -e "${Green}Calculating image tags based on current commit level...${ColorOff}"
  for key in "${!ACSIMAGES[@]}"; do
    val="${ACSIMAGES[$key]}"
    if [[ ! -z "${TAGPATH[$key]}" ]]; then
      # The image need to be specially processed
      tag=$(yq ${TAGPATH[$key]} /home/polaris/pcloud/charts/${TAGYAML[$key]})
      if [[ -z "${tag}" ]]; then
        echo -e "${Red}Image ${key} tag path cannot be found, this is a fatal error${ColorOff}"
        exit 1
      fi
      imagename="${key}:${tag}"
      echo "   ${imagename}"
      allimages[$imagename]=${val}
    else
      # The image tag should be retrieved from the git level
      comp="${key}"
      if [[ ! -z "${val}" ]]; then
        comp="${val}"
      fi
      tag=$(/home/polaris/cicd/scripts/calculate_service_version.sh ${comp} --release-versioning false||true)
      imagename="${key}:${tag}"
      echo "   ${imagename}"
      allimages[$imagename]=''
    fi
  done
  saveAllImageTags
}

function pullAstraComponentImage() {
  imagerepo=$1
  imagename=$2
  imageparts=(${imagename//:/ })
  name=${imageparts[0]}
  tag=${imageparts[1]}
  flag=${allimages[$imagename]}
  if [[ -z "${flag}" ]]; then
    flag=${ACSIMAGES[${name}]}
  fi
  if [[ "${flag}" == 'd' ]]; then
    echo -e "${Green}Pulling public image ${imagename}${ColorOff}"
    docker pull ${imagename}
  else
    echo -e "${Green}Pulling Astra Control image ${imagename}${ColorOff}"
    pullAndTag ${imagerepo} ${name} ${tag}
  fi
}

function pullACImages() {
  # repologin="https://${IMAGE_REPOSITORY}/v2/"
  # response=$(docker login -u ${CREDS_IMAGE_USERNAME} -p ${CREDS_IMAGE_PASSWORD} ${IMAGE_REPOSITORY})
  loginToDockerHub
  imagerepo="${IMAGE_REPOSITORY}/globalcicd/astra/"
  if [[ "${IMAGENAME}" == "" ]]; then
    loadAllImageTags
    size=$(echo ${#allimages[@]})
    if [ "$size" -lt "2" ]; then
      getAllImages
    fi
    echo -e "${Green}Start pulling Astra images...${ColorOff}"
    for imagename in "${!allimages[@]}"; do
      pullAstraComponentImage "${imagerepo}" "${imagename}"
    done
  else
    pullAstraComponentImage "${imagerepo}" "${IMAGENAME}"
  fi
}

# pushAstraComponentImage only pushes image to the local
# image repository.
function pushAstraComponentImage() {
  imagename=$1
  imageparts=(${imagename//:/ })
  name=${imageparts[0]}
  tag=${imageparts[1]}
  flag=${allimages[$imagename]}
  if [[ -z "${flag}" ]]; then
    flag=${ACSIMAGES[${name}]}
  fi
  if [[ "${flag}" == 'd' ]]; then
    echo -e "${Green}Ready to push public image ${imagename}${ColorOff}"
    ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${imagename}" --context ${CONTEXT}
  else
    echo -e "${Green}Ready to push ${imagename}${ColorOff}"
    ${SCRIPTDIR}/k8stool image --source-tag "${imagename}"
  fi
}

function pushACImages() {
  # repologin="https://${IMAGE_REPOSITORY}/v2/"
  # response=$(docker login -u ${CREDS_IMAGE_USERNAME} -p ${CREDS_IMAGE_PASSWORD} ${IMAGE_REPOSITORY})
  if [[ "${IMAGENAME}" == "" ]]; then
    size=$(echo ${#allimages[@]})
    if [ "$size" -lt "2" ]; then
      getAllImages
    fi
    echo -e "${Green}Pushing images...${ColorOff}"
    for imagename in "${!allimages[@]}"; do
      pushAstraComponentImage "${imagename}"
    done
  else
    pushAstraComponentImage "${IMAGENAME}"
  fi
}

function refreshDeployment() {
  if [[ "${DEPLOYMENT}" == "" ]]; then
    echo -e "${Red}Use -d parameter to specify a deployment to be refreshed${ColorOff}"
    exit 1
  else
    OLDIFS=$IFS
    dep=$(kubectl --context ${CONTEXT} get -n ${NAMESPACE} deployment "${DEPLOYMENT}" -o \
      jsonpath='{.spec.template.spec.containers[*].image}' 2>/dev/null||true)
    if [[ "${dep}" == "" ]]; then
      echo -e "${Red}Could not find the deployment ${DEPLOYMENT}${ColorOff}"
      IFS=$OLDIFS
      exit 1
    else
      # Now need to get the tag and the actual image name
      IFS=$'/' parts=($(echo "${dep}"|rev))
      imagename=$(echo "${parts[0]}"|rev)
      IFS=$OLDIFS
      if [[ "${imagename}" != "" ]]; then
        echo "Ready to update ${imagename}"
        if [[ "${dep}" =~ "localhost:5001/" ]]; then
          # astra image, push the newer image
          ${SCRIPTDIR}/k8stool image --source-tag "${imagename}"
          # Remove the cached image
          docker exec astra-control-plane crictl rmi "${dep}" 2>/dev/null || true
        else
          # other images
          ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${imagename}"
        fi
        kubectl --context ${CONTEXT} rollout restart -n ${NAMESPACE} deployment ${DEPLOYMENT}
      fi
    fi
  fi
}
#=================Start main process=========================

set -e
# cluster processes
if [[ "${CMD}" == "up" ]]; then
  echo ""
  checkInPolaris
  checkEnvironmentVariables

  echo ""
  pullACImages
  echo ""  
  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  echo -e "${Green}Upload Astra images to image repostiory"
  validateContext
  pushACImages
  echo -e "${Green}Create traefik certificate${ColorOff}"
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"

  deployAC "${COMPONENT}"

elif [[ "${CMD}" == "prepare" ]]; then
  echo ""
  checkInPolaris
  checkEnvironmentVariables

  echo ""
  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  echo -e "${Green}Upload Astra images to image repostiory"
  validateContext
  pushACImages
  echo -e "${Green}Create traefik certificate${ColorOff}"
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  echo -e "${Green}Ready to deploy Astra, please run deploy command${ColorOff}"

elif [[ "${CMD}" == "down" ]]; then
  echo ""
  echo -e "${Green}Removing Astra main components...${ColorOff}"
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  KUBE_CONTEXT=${CONTEXT} SKIP_KUBE_CONTEXT_CHECK=true \
    make helmuninstall DEPLOY_TARGET=cicd

elif [[ "${CMD}" == "clean" ]]; then
  echo -e "${Green}Removing Astra and cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d

elif [[ "${CMD}" == "cleanall" ]]; then
  echo -e "${Green}Removing everything...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d
  # Remove the proxy and the local registry as well
  docker rm -f kubeproxy &> /dev/null || true
  docker rm -f kind-registry &> /dev/null || true
  # Need to clean up docker volumes
  docker volume prune -f &> /dev/null || true

elif [[ "${CMD}" == "image" ]]; then
  validateContext
  pushACImages

elif [[ "${CMD}" == "deploy" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  # Always check and recreate namespace and the cert in case it was removed
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  deployAC "${COMPONENT}"

elif [[ "${CMD}" == "pull" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  pullACImages

elif [[ "${CMD}" == "refresh" ]]; then
  checkInPolaris
  checkEnvironmentVariables
  validateContext
  refreshDeployment
elif [[ "${CMD}" == "update" ]]; then
  checkEnvironmentVariables
  doADTUpdate
elif [[ "${CMD}" == "make" ]]; then
  make "${REST}"
fi
#=================End main process=========================
