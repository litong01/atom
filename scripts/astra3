#!/bin/bash

ColorOff='\033[0m'        # Text Reset
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
SCRIPTDIR=$(dirname $0)
APPNAME=$(basename "$0")
TYPE="acc"
CURDIR=$(pwd)
WORKDIR=${WORKDIR:-/tmp/astra3}
COMPONENT="all"
NAMESPACE="${NAMESPACE:-neptune-system}"
DEPLOYMENT="${DEPLOYMENT:-neptune-controller-manager}"
IMAGE_REPOSITORY=${IMAGE_REPOSITORY:-docker.repo.eng.netapp.com/globalcicd/astra}
IMAGENAME=""

function printHelp() {
  echo ""
  echo "Usage:"
  echo "    ${APPNAME} <cmd> [options]"
  echo ""
  echo -e "Available commands:"
  echo "     up       - Start up astra network include cluster"
  echo "     down     - Remove all astra but k8s cluster"
  echo "     image    - Update image to the local repo"
  echo "     prepare  - Get cluster and image ready"
  echo "     deploy   - Deploy astra components"
  echo "     clean    - Remove all astra including k8s cluster"
  echo "     cleanall - Remove all astra including k8s cluster, proxy, local registry"
  echo "     update   - update this tool"
  echo "     refresh  - restart a deployment and its image"
  echo "     make     - run polaris make command"
  echo "     bash     - run bash interactively"
  echo ""
  echo -e "Parameters for ${Green}refresh${ColorOff} command:"
  echo "     -d|--deployment-name  - a deployment name such as neptune-controller-manager"
  echo "     -n|--namespace        - the namespace where the deployment is, default neptune-system"
  echo ""
}

function validateCMD() {
  cmd=$1
  allCommands=("up" "down" "image" "deploy" "clean" "cleanall" "prepare" "refresh" "make" \
    "update" "k8stool" "bash" "addon")
  ccmd=""
  for item in "${allCommands[@]}"; do
    if [[ "${cmd}" == "${item}" ]]; then
      ccmd="${cmd}"
      isValidCMD="true"
      break
    fi
  done
  if [[ -z "${ccmd}" ]]; then
    if [[ "${cmd}" != "-h" ]] && [[ "${cmd}" != "--help" ]] && [[ "${cmd}" != "" ]]; then
      echo ""
      echo -e "ERROR: ${Red}${cmd}${ColorOff} is not a supported command!"
      printHelp "${isValidCMD}"
      exit 1
    else
      printHelp "${isValidCMD}"
      exit 0
    fi
  fi
}

CMD=$1
shift
# This saves the rest of the command in case it is to pass along for make command
REST="$@"
# Validate the command
validateCMD "${CMD}"

# We will only handle command parameters if command was not make and not k8stool
if [[ "${CMD}" == "make" || "${CMD}" == "k8stool" || "${CMD}" == "bash" ]]; then
  echo ""
else
  # Handling parameters
  while [[ $# -gt 0 ]]; do
    optkey="$1"
    case $optkey in
      -h|--help)
        printHelp "true"; exit 0;;
      --context)
        CONTEXT="$2";shift 2;;
      --targetports)
        TARGETPORTS="$2";shift 2;;
      -n|--namespace)
        NAMESPACE="$2";shift 2;;
      -w|--workdir)
        WORKDIR="$2";shift 2;;
      -a|--astra-name)
        COMPONENT="$2";shift 2;;
      -d|--deployment-name)
        DEPLOYMENT="$2";shift 2;;
      -i|--imagename)
        IMAGENAME="$2";shift 2;;
      -r|--releaseimage)
        RELEASEIMAGE="$2";shift 2;;
      -t|--type)
        TYPE="$2";shift 2;;
      *) # unknown option
        echo "parameter $1 is not supported"; exit 1;;
    esac
  done
fi


function validateContext() {
  # Context was not set, trying to use current context
  if [[ -z "${CONTEXT}" ]]; then
    # Get current context
    ctx=$(kubectl config current-context 2>/dev/null || true)
  else # Context was set, verify it exists in the kubernetes context
    ctx=$(kubectl config get-contexts "${CONTEXT}" -o=name 2>/dev/null || true)
  fi

  if [[ -z "${ctx}" ]]; then
    echo -e "${Red}No kubernetes context available, cannot continue${ColorOff}"
    exit 1
  fi

  CONTEXT="${ctx}"
}

function installStorageCRDs() {
  kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-5.0/client/config/crd/snapshot.storage.k8s.io_volumesnapshotclasses.yaml
  kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-5.0/client/config/crd/snapshot.storage.k8s.io_volumesnapshotcontents.yaml
  kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-5.0/client/config/crd/snapshot.storage.k8s.io_volumesnapshots.yaml
}


function doADTUpdate() {
  adtimage=$(docker inspect astra3 --format "{{.Config.Image}}" 2>/dev/null || true)
  if [[ ! -z "${adtimage}" ]]; then
    # Using the github token and id to login
    echo $GITHUB_TOKEN | docker login -u ${GITHUB_ID} --password-stdin ghcr.io >/dev/null 2>&1
    # Pull the image
    docker pull "${adtimage}"
    docker pull ghcr.io/netapp-polaris/polaris/astra/acc-operator:astradt
    docker tag ghcr.io/netapp-polaris/polaris/astra/acc-operator:astradt acc-operator:astradt
    # Try to clean up dangling images, use a variable to avoid none 0 return
    notuseval=$(docker rmi -f $(docker images -f "dangling=true") >/dev/null 2>&1 || true)
  fi
}

function loginToDockerHub() {
  if [[ ! -z "${GITHUB_ID}" ]] && [[ ! -z "${GITHUB_TOKEN}" ]]; then
    echo -e "${Green}Logging into docker hub...${ColorOff}"
    echo $DH_TOKEN | docker login -u $DH_ID --password-stdin docker.io >/dev/null 2>&1
  fi
}

function checkInNeptune() {
    projectName=$(cat PROJECT | yq '.projectName')
    if [[ ! -f "${CURDIR}/Makefile" ]] || [[ "${projectName}" != "neptune" ]]; then
      echo -e "${Red}You are not in neptune root directory, quiting...${ColorOff}"
      exit 1
    fi
}

function checkEnvironmentVariables() {
  envs=(REGISTRY REGISTRY_USERID REGISTRY_TOKEN TAG PLATFORMS)
  for value in ${envs[@]}; do
    if [[ "${value}" == "REGISTRY_TOKEN" ]]; then
      echo -e "${Green}${value}${ColorOff}=************"
    else
      echo -e "${Green}${value}${ColorOff}=${!value}"
    fi
  done
  echo ""
}

function wait_for_pod() {
  namespace=$1
  podlabel=$2
  condition=$3
  while : ; do
    waitresult=$(kubectl wait pod --context ${CONTEXT} -n ${namespace} --for=condition=${condition} \
      -l "app.kubernetes.io/name in (${podlabel})" --timeout=60s 2>/dev/null || true)
    # If the wait returns, it can only be either timed out or condition met. We check if there is
    # timedout, we continue to wait. Since the timeout is an error, and it goes to /dev/null, only
    # condition met will have anything in waitresult, in any other condition, the waitresult is empty.
    if [[ -z "${waitresult}" ]]; then
      currentTime=$(date +%s)
      elapsed=$(( currentTime - startTime ))
      echo -ne "\033[0K\r"
      echo -ne "   Time elapsed: ${Green}${elapsed}${ColorOff} seconds\033[0K"
    else
       break
    fi
  done
  echo ""
  echo -e "${Green}AC pods are ready now${ColorOff}"
}

function deployNeptune() {
  echo -e "${Green}Deploying Neptune...${ColorOff}"
  export IMG=kind-registry:5001/controller:latest
  export NEPTUNE_BIN=${LOCALBIN}
  make install
  make deploy
}

function doNeptuneImage() {
  echo -e "${Green}Setting up Neptune Manager image...${ColorOff}"
  img=$(docker image ls controller:latest --quiet)
  if [[ -z "${img}" ]]; then
    img=$(docker image ls kind-registry:5001/controller:latest --quiet)
    if [[ -z "${img}" ]]; then
      echo -e "${Red}No local image exist, do a docker build first${ColorOff}"
      return
    fi
  fi

  docker tag ${img} localhost:5001/controller:latest
  docker push localhost:5001/controller:latest
}

function refreshDeployment() {
  if [[ "${DEPLOYMENT}" == "" ]]; then
    DEPLOYMENT="neptune-controller-manager"
  fi

  OLDIFS=$IFS
  dep=$(kubectl --context ${CONTEXT} get -n ${NAMESPACE} deployment "${DEPLOYMENT}" -o \
    jsonpath='{.spec.template.spec.containers[*].image}' 2>/dev/null||true)
  if [[ "${dep}" == "" ]]; then
    echo -e "${Red}Could not find the deployment ${DEPLOYMENT}${ColorOff}"
    echo -e "${Green}If the deployment was not installed in neptune-system, you can use -n to specify${ColorOff}"
    IFS=$OLDIFS
    exit 1
  else
    # Now need to get the tag and the actual image name
    IFS=$'/' parts=($(echo "${dep}"|rev))
    imagename=$(echo "${parts[0]}"|rev)
    IFS=$OLDIFS
    if [[ "${imagename}" != "" ]]; then
      echo "Ready to update ${imagename}"
      if [[ "${dep}" =~ "${IMAGE_HOST}" ]]; then
        # astra image, push the newer image
        ${SCRIPTDIR}/k8stool image --source-tag "${imagename}"
        # Remove the cached image
        docker exec astra-control-plane crictl rmi "${dep}" 2>/dev/null || true
      else
        # other images
        ${SCRIPTDIR}/k8stool image --load-or-push true --source-tag "${imagename}"
      fi
      kubectl --context ${CONTEXT} rollout restart -n ${NAMESPACE} deployment ${DEPLOYMENT}
    fi
  fi
}

function doAddon() {

  # This section deploys hashcorp vault onto the cluster
  helm repo add hashicorp https://helm.releases.hashicorp.com >/dev/null 2>&1
  kubectl create namespace vault >/dev/null 2>&1
  helm install vault hashicorp/vault --namespace vault >/dev/null 2>&1
  # wait_for_pod vault vault Initialized
  sleep 20
  kubectl exec -ti -n vault statefulset/vault -- vault operator init --format json > /home/work/astra3/vault.key.json
  allkeys=($(cat /home/work/astra3/vault.key.json | jq -r '.unseal_keys_b64 | join(" ")'))
  for key in ${allkeys[@]}; do
    kubectl exec -ti -n vault statefulset/vault -- vault operator unseal ${key} >/dev/null 2>&1
  done

  # This section setup minio onto the cluster
  kubectl apply -f /home/work/addon/minio-dev.yaml
}

#=================Start main process=========================

set -e
checkEnvironmentVariables

# cluster processes
if [[ "${CMD}" == "up" ]]; then
  echo ""
  checkInNeptune

  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  validateContext
  installStorageCRDs

  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  
  doNeptuneImage
  deployNeptune

elif [[ "${CMD}" == "prepare" ]]; then
  echo ""
  checkInNeptune

  echo ""
  echo -e "${Green}Setting up kubernetes cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool clusters --workdir "${WORKDIR}" --target-dir "${WORKDIR}"
  validateContext
  installStorageCRDs

  validateContext

  # echo -e "${Green}Create traefik certificate${ColorOff}"
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"

  echo -e "${Green}Ready to deploy Astra Neptune, please run deploy command${ColorOff}"

elif [[ "${CMD}" == "down" ]]; then
  echo ""
  echo -e "${Green}Removing Neptune CRDs and Controller...${ColorOff}"
  checkInNeptune

  make undeploy
  make uninstall

elif [[ "${CMD}" == "clean" ]]; then
  echo -e "${Green}Removing Astra and cluster...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d

elif [[ "${CMD}" == "cleanall" ]]; then
  echo -e "${Green}Removing everything...${ColorOff}"
  ${SCRIPTDIR}/k8stool cluster -d
  # Remove the proxy and the local registry as well
  docker rm -f kubeproxy &> /dev/null || true
  docker rm -f kind-registry &> /dev/null || true
  # Need to clean up docker volumes
  docker volume prune -f &> /dev/null || true

elif [[ "${CMD}" == "deploy" ]]; then
  checkInNeptune
  validateContext
  # Always check and recreate namespace and the cert in case it was removed
  ${SCRIPTDIR}/k8stool cert --namespace ${NAMESPACE} --context ${CONTEXT} --workdir "${WORKDIR}"
  deployNeptune

elif [[ "${CMD}" == "refresh" ]]; then
  checkInNeptune
  validateContext
  refreshDeployment

elif [[ "${CMD}" == "image" ]]; then
  doNeptuneImage

elif [[ "${CMD}" == "update" ]]; then
  doADTUpdate

elif [[ "${CMD}" == "addon" ]]; then
  doAddon

elif [[ "${CMD}" == "make" ]]; then
  checkInNeptune

  if [[ "$REST" == "all-buildx" ]]; then

    # Only login to image repository when both registry userid and token are available
    # this is to allow publish to the image repo will be successful
    if [[ ! -z $REGISTRY_USERID ]] && [[ ! -z $REGISTRY_TOKEN ]]; then
      # Login to the registry only to allow multiarch image built and push easier
      if [[ -z "$REGISTRY" ]]; then
        echo ${REGISTRY_TOKEN} | docker login docker.io -u ${REGISTRY_USERID} --password-stdin >/dev/null 2>&1
        REGISTRY="${REGISTRY_USERID}/"
      else
        echo ${REGISTRY_TOKEN} | docker login ${REGISTRY} -u ${REGISTRY_USERID} --password-stdin >/dev/null 2>&1
      fi
    fi
  fi

  # We are ready to execute,
  REGISTRY=${REGISTRY} PLATFORMS=${PLATFORMS} make ${REST}

elif [[ "${CMD}" == "bash" ]]; then
  checkInNeptune
  echo -e "${Green}Entering bash session...${ColorOff}"
  # env IMG=kind-registry:5001/controller:latest bash
  bash
fi
#=================End main process=========================
