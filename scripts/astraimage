#!/bin/bash

declare -A EXTIMAGES     #external images required
declare -A ACIMAGES      #astra images required
declare -A EXTImageNameTag     #external image name to tag map
declare -A EXTImageFullnameTag   #external image name to fullname map

if [[ "${TYPE}" == "acs" ]]; then
  # Define ACS images needed
  EXTIMAGES=(['hashicorp/vault']='' \
    ['nats']='' \
    ['traefik']='' \
    ['theotw/httpproxy-server']='' \
    ['theotw/k8srelayserver']='' \
    ['theotw/natssync-server']='')

  ACIMAGES=(['activity']='' ['activity_upgrade']='activity' ['astra-py-k8s']='' ['billing']='' ['bucketservice']='' ['cloud-extension']='' \
    ['composite-compute']='' ['composite-volume']='' ['credentials']='' ['entitlement']='' ['features']='' \
    ['features_upgrade']='features' ['graphql-server']='' ['hybridauth']='' ['identity']='' ['krakend']='' \
    ['nautilus']='' ['openapi']='' ['polaris-ui']='' ['support']='' ['support_hourly']='support' ['support_upgrade']='support' \
    ['support_weekly']='support' ['task-service']='' ['task-service_task_purge']='task-service' \
    ['tenancy']='' ['tenancy_account_purge']='tenancy' ['trident-svc']='' ['nk']='' ['container-registry']='')

else
  # Define ACC images needed
  EXTIMAGES=(['au-pod']='' \
    ['bitnami/mongodb-exporter']='' \
    ['bitnami/mongodb']='' \
    ['distroless-root-user']='' \
    ['docker.io/bitnami/mariadb-galera']='' \
    ['docker.repo.eng.netapp.com/global/astra/astra-py-k8s']='' \
    ['fluent/fluent-bit']='' \
    ['grafana/loki']='' \
    ['hashicorp/consul']='' \
    ['hashicorp/vault']='' \
    ['influxdb']='' \
    ['k8s.gcr.io/kube-state-metrics/kube-state-metrics']='' \
    ['kube-rbac-proxy']='' \
    ['nats']='' \
    ['netapp-monitoring']='' \
    ['netappdownloads.jfrog.io/oss-docker/harvest']='' \
    ['netappdownloads.jfrog.io/oss-docker/restic']='' \
    ['nk']='' \
    ['opsgenie/kubernetes-event-exporter']='' \
    ['quay.io/jetstack/cert-manager-acmesolver']='' \
    ['quay.io/jetstack/cert-manager-cainjector']='' \
    ['quay.io/jetstack/cert-manager-controller']='' \
    ['quay.io/jetstack/cert-manager-ctl']='' \
    ['quay.io/jetstack/cert-manager-webhook']='' \
    ['telegraf']='' \
    ['theotw/httpproxy-server']='' \
    ['theotw/natssync-server']='' \
    ['traefik']='')

  ACIMAGES=(['activity']='' ['activity_upgrade']='activity' ['astra-py-k8s']='' ['billing']='' ['bucketservice']='' ['asup']='' ['packages']='' ['license']='' \
    ['cloud-extension']='' ['composite-compute']='' ['composite-volume']='' ['credentials']='' ['cloud-insights-service']='' \
    ['entitlement']='' ['features']='' ['features_upgrade']='features' ['public-metrics']='' ['keycloak-operator']='' \
    ['graphql-server']='' ['hybridauth']='' ['identity']='' ['krakend']='' ['nautilus']='' ['openapi']='' ['polaris-ui']='' \
    ['support']='' ['support_hourly']='support' ['support_weekly']='support' ['task-service']='' ['authentication']='' \
    ['task-service_task_purge']='task-service' ['tenancy']='' ['tenancy_account_purge']='tenancy' ['metrics-facade']='' \
    ['trident-svc']='' ['vault-controller']='' ['certificates_upgrade']='certificates' \
    ['api-token-authentication']='' ['storage-backend-metrics']='' ['storage-provider']='' ['telemetry-service']='' \
    ['polaris-keycloak']='' ['login-ui']='' ['certificates']='')
fi

function externalImages() {
  # This is an example to remove some not wanted.
  # accExtImages=$(cat ${CURDIR}/enterprise/external-services.json | jq '.services' |
  #   jq 'map(."container-images") | flatten | unique |
  #      del(..|select(. =="bitnami/mongodb-exporter:0.33.0-debian-11-r9")) | del(..|select(. =="bitnami/mongodb:5.0.10-debian-11-r3"))' |
  #   jq '.[]')

  # Get all external images needed from the external-services.json file
  accExtImages=$(cat ${CURDIR}/enterprise/external-services.json | jq '.services' |
    jq 'map(."container-images") | flatten | unique' | jq '.[]')

  if [[ ${#accExtImages[@]} == 0 ]]; then
    echo -e "${Red}No external image found, this is an error, quiting...${ColorOff}"
    exit 1
  fi

  # Since the mongodb is special, we have to add it here
  # accExtImages+=("ghcr.io/zcube/bitnami-compat/mongodb:5.0.14")

  for anItem in ${accExtImages[@]}; do
    # Strip the quotes if there are any
    anItem="${anItem%\"}"; anItem="${anItem#\"}"
    # anItem is the full image with its registry
    # anImage is the image name without its registry
    anImage=$(echo ${anItem} | rev | cut -d '/' -f 1|rev)
    imageName=$(echo ${anImage} | cut -d ':' -f 1)
    imageTag=$(echo ${anImage} | cut -d ':' -f 2)
    imageFullname=$(echo ${anItem} | cut -d ':' -f 1)
    EXTImageNameTag[${imageName}]="${imageTag}"
    EXTImageFullnameTag[${imageName}]="${imageFullname}"
  done

  #We have to deal with the stupid practice of randomly adding new image
  EXTImageNameTag['k8srelayserver']="2.1.202305112214"
  EXTImageFullnameTag['k8srelayserver']="theotw/k8srelayserver"
}

# This method returns a value indicating if an element exists in a map
function existInMap() {
  element=$1
  map=$2
  if [[ -v "$map[$element]" ]]; then
    echo "true"
  else
    echo "false"
  fi      
}

# Return a componnet image tag based on short name or full name
# Way to call this method
#     tag=$(GetACComponentImageTag  componentName)
# Now variable tag contains the image tag
function GetACComponentImageTag() {
  if [[ "${#EXTImageNameTag[@]}" == 0 ]]; then
    externalImages
  fi
  version=""
  cpname=$1
  
  isACImage=$(existInMap ${cpname} ACIMAGES)
  if [[ "${isACImage}" == "true" ]]; then
    # Handling this image is messed up.
    if [[ "${cpname}" == "astra-py-k8s" ]] || [[ "${cpname}" == "nk" ]]; then
      version="${EXTImageNameTag[$cpname]}"
    else
      fetchName="${ACIMAGES[$cpname]}"
      if [[ -z "${fetchName}" ]]; then
        fetchName="${cpname}"
      fi
      version=$(${CURDIR}/cicd/scripts/calculate_service_version.sh ${fetchName} --release-versioning false)
    fi
  fi
  echo "${version}"
}

# This method logs into both docker hub and git hub if variables are set
function loginToImageHub() {
  if [[ ! -z "${DH_ID}" ]] && [[ ! -z "${DH_TOKEN}" ]]; then
    echo -e "${Green}Logging into docker hub...${ColorOff}"
    echo $DH_TOKEN | sudo docker login -u $DH_ID --password-stdin docker.io >/dev/null 2>&1
  fi
  if [[ ! -z "${GITHUB_ID}" ]] && [[ ! -z "${GITHUB_TOKEN}" ]]; then
    echo -e "${Green}Logging into git hub...${ColorOff}"
    echo $GITHUB_TOKEN | sudo docker login -u $GITHUB_ID --password-stdin ghcr.io >/dev/null 2>&1
  fi
}

# This function will pull the images from the repo which defined in IMAGE_REPOSITORY
function imagePullTagPush() {
  iname=$1  # the image short name
  itag=$2   # the image tag
  ifullname=$3  # the image fullname
  isexternal=$4  # is external or ac image

  echo -e "   Processing ${Green}${ifullname}:${itag}${ColorOff}..."
  # We first check the local image without repository, it may be just built locally, we always use
  # that, we are a development tool after all.

  anImage=$(sudo docker images "${iname}:${itag}" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
  if [[ -z "${anImage}" ]]; then
    # no local image without repository, now check if has been downloaded before and tagged as localhost:5001
    anImage=$(sudo docker images "localhost:5001/${iname}:${itag}" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
    # The image already exists locally, do not need to pull
    if [[ -z "${anImage}" ]]; then
      sudo docker pull "${IMAGE_REPOSITORY}/${iname}:${itag}"
      sudo docker tag "${IMAGE_REPOSITORY}/${iname}:${itag}" "localhost:5001/${iname}:${itag}"
      if [[ "${TYPE}" == "acs" ]]; then
        # If this is ACS deployment, we need to tag the image to be the original repo
        sudo docker tag "${IMAGE_REPOSITORY}/${iname}:${itag}" "${ifullname}:${itag}"
      fi
    else
      echo -e "   ${Green}Already exists locally, skip pulling${ColorOff}"
    fi
  else
    sudo docker tag "${iname}:${itag}" "localhost:5001/${iname}:${itag}"
  fi

  if [[ "${TYPE}" == "acc" ]] || [[ "${isexternal}" == "false" ]]; then
    sudo docker push "localhost:5001/${iname}:${itag}"
  elif [[ "${TYPE}" == "acs" ]]; then
    # It is possible that the image was pulled from astra image repo, the actual full named image may have not be
    # tagged. so we check that as well.
    anImage=$(sudo docker images "${ifullname}:${itag}" --format "{{.Repository}}:{{.Tag}}" 2>/dev/null || true)
    if [[ -z "${anImage}" ]]; then
      sudo docker tag "localhost:5001/${iname}:${itag}" "${ifullname}:${itag}"
    fi
    sudo kind load docker-image -n astra "${ifullname}:${itag}"
  else
    echo "The deployment type can only to be either acc or acs"
    exit 1
  fi
}

function tagOneImage() {
  # docker load returns something like this
  #  Loaded image: loki:2.3.0
  # we split the string to get image name and tag
  IFS=':' read -ra PARTS <<< "${1}"
  PART1=$(echo "${PARTS[1]}" | xargs)
  PART2=$(echo "${PARTS[2]}" | xargs)
  if [[ ! -z "${PART1}" && ! -z "${PART2}" ]]; then
    echo -e "${Green}Ready to tag ${PART1}:${PART2}${ColorOff}"
    sudo docker tag "${PART1}:${PART2}" "localhost:5001/${PART1}:${PART2}"
    # docker tag "${PART1}:${PART2}" "${IMAGE_REPOSITORY}/${PART1}:${PART2}"
    sudo docker push "localhost:5001/${PART1}:${PART2}"
  else
    echo -e "${Red}The image cannot be processed, missing name or tag${ColorOff}"
    exit 1
  fi
}

function loadUpReleaseImages() {
  bundlename=$1
  mkdir -p /home/work/astra/releasebundle
  echo -e "${Green}Unpack release images...${ColorOff}"
  tar -xzf ${bundlename} -C /home/work/astra/releasebundle
  for relimage in "/home/work/astra/releasebundle/acc/images"/*.tar
  do
    echo -e "${Green}${relimage}${ColorOff}..."
    result=$(sudo docker load --input ${relimage})
    tagOneImage "${result}"
  done
}

function ImportReleaseImages() {
  # This method search the home/work/astra directory for astra control center tar gz files
  # if there is one, it will unpack and load up to the host docker registry.
  for entry in "/home/work/astra/astra-control-center-"*.tar.gz
  do
    echo -e "Process Release ${Green}${entry}${ColorOff} images..."
    loadUpReleaseImages "${entry}"
  done
}

# This method will setup all necessary ACS or ACC images
function SetupACComponentImage() {
  if [[ "${#EXTImageNameTag[@]}" == 0 ]]; then
    externalImages
  fi

  # handle release images if there are any placed in /tmp/astra directory.
  if [[ "${RELEASEIMAGE}" == "true" ]]; then
    ImportReleaseImages
    return
  fi

  # Process external images first
  for ifullname in "${!EXTIMAGES[@]}"; do
    iname=$(echo ${ifullname} | rev | cut -d '/' -f 1|rev)
    itag="${EXTImageNameTag[$iname]}"    # the required image tag
    imagePullTagPush "${iname}" "${itag}" "${EXTImageFullnameTag[$iname]}" "true"
  done

  for iname in "${!ACIMAGES[@]}"; do
    itag=$(GetACComponentImageTag "${iname}")
    imagePullTagPush "${iname}" "${itag}" "${iname}" "false"
  done

  # Now handling the mongodb image since it is special
  PullTagPushOneExtImage "ghcr.io/zcube/bitnami-compat/mongodb:5.0.14"
  # Now handling the k8srelayserver since it is yet another special image
  imagePullTagPush "k8srelayserver" "2.1.202305112214" "theotw/k8srelayserver" "false"

  # Fix the use of the nk in the script for ACS
  if [[ "${TYPE}" == "acs" ]]; then
    doTagNK
  else
    imagePullTagPush "kube-rbac-proxy" "v0.13.0" "kube-rbac-proxy" "true"
  fi
}

function PullTagPushOneACImage() {
  if [[ "${#EXTImageNameTag[@]}" == 0 ]]; then
    externalImages
  fi
  iname=$(echo ${1} | cut -d ':' -f 1)
  itag=$(echo ${1} | cut -d ':' -f 2)
  imagePullTagPush "${iname}" "${itag}" "${iname}" "true"
}

function PullTagPushOneExtImage() {
  # Login to the various hub if configured.
  loginToImageHub
  # Pull the image
  sudo docker pull "${1}"
  # Load to astra cluster nodes
  # kind load docker-image -n astra "${1}"
  anImage=$(echo ${1} | rev | cut -d '/' -f 1|rev)
  imageName=$(echo ${anImage} | cut -d ':' -f 1)
  imageTag=$(echo ${anImage} | cut -d ':' -f 2)
  imageFullname=$(echo ${1} | cut -d ':' -f 1)
  sudo docker tag "${1}" "localhost:5001/${imageName}:${imageTag}"
  sudo docker push "localhost:5001/${imageName}:${imageTag}"
}

function doTagNK() {
  itag="${EXTImageNameTag['nk']}"
  sudo docker tag "localhost:5001/nk:${itag}" "${IMAGE_HOST}/nk:${itag}" >/dev/null 2>&1
}